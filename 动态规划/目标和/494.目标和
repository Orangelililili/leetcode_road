https://leetcode.cn/problems/target-sum/description/

class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        // 计算数组中所有元素的总和
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];

        // 如果目标值的绝对值大于总和，说明无法通过加减得到目标值，返回 0
        if (abs(target) > sum) return 0;

        // 如果 (target + sum) 是奇数，说明无法通过加减得到目标值，返回 0
        // 因为 (target + sum) 必须是偶数才能被 2 整除，从而得到背包容量
        if ((target + sum) % 2 == 1) return 0;

        // 计算背包容量 bagSize，即 (target + sum) / 2
        // 这个背包容量表示我们需要从数组中找到一些元素，使得它们的和等于 bagSize
        int bagSize = (target + sum) / 2;

        // 初始化动态规划数组 dp，大小为 bagSize + 1，初始值为 0
        // dp[j] 表示和为 j 的方案数
        vector<int> dp(bagSize + 1, 0);

        // 初始化 dp[0] 为 1，表示和为 0 的方案数为 1（即不选任何元素）
        dp[0] = 1;

        // 遍历数组中的每个元素
        for (int i = 0; i < nums.size(); i++) {
            // 从背包容量 bagSize 开始，倒序遍历到当前元素的值 nums[i]
            // 倒序遍历是为了避免重复计算（即每个元素只能使用一次）
            for (int j = bagSize; j >= nums[i]; j--) {
                // 更新 dp[j]，表示加上当前元素 nums[i] 后，和为 j 的方案数
                // dp[j] += dp[j - nums[i]] 表示：
                // 如果和为 j - nums[i] 的方案数为 dp[j - nums[i]]，那么加上 nums[i] 后，和为 j 的方案数增加 dp[j - nums[i]]
                dp[j] += dp[j - nums[i]];
            }
        }

        // 返回 dp[bagSize]，即和为 bagSize 的方案数
        return dp[bagSize];
    }
};