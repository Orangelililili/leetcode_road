https://leetcode.cn/problems/coin-change-ii/description/

class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int bagSize = amount;
        //coins数组就是物品（不限量），
        vector<vector<uint64_t>> dp(coins.size(), vector<uint64_t>(bagSize + 1, 0));

        // 初始化最上行，能整除说明若干个coins[0]可以凑出来j
        for (int j = 0; j <= bagSize; j++) {
            if (j % coins[0] == 0) dp[0][j] = 1;
        }
        // 初始化最左列，0块钱，不论面值是多少，只有一种可能就是不选
        for (int i = 0; i < coins.size(); i++) {
            dp[i][0] = 1;
        }
        // 以下遍历顺序行列可以颠倒
        for (int i = 1; i < coins.size(); i++) { // 行，遍历物品
            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包
                if (coins[i] > j) dp[i][j] = dp[i - 1][j]; //面值太大就是上一行复制
                //小于等于都可以，
                //因为​​dp[i-1][j]​​：表示​​不选​​当前硬币 coins[i]，直接用前 i-1 种硬币凑出金额 j 的组合数。
​                //​dp[i][j - coins[i]]​​：表示​​选​​当前硬币 coins[i]，然后凑剩余金额j-coins[i]的组合数
                //（因为硬币无限，可以重复选）
                else dp[i][j] = dp[i - 1][j] +  dp[i][j - coins[i]];
            }
        }
        return dp[coins.size() - 1][bagSize];//表格最右下就是结果
    }
};