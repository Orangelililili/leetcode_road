[TOC]
# 二分查找理论基础

## 1. 二分查找的基本概念

**二分查找（Binary Search）**是一种在有序数组中查找特定元素的搜索算法。每次比较后，搜索范围会缩小一半，因此时间复杂度为O(log n)。

### 1.1 基本术语

- **有序数组**：数组必须是有序的（升序或降序）
- **目标值（Target）**：要查找的元素
- **搜索区间**：当前查找的范围 [left, right]
- **中点（Mid）**：搜索区间的中间位置
- **边界**：左边界和右边界，用于确定搜索范围

### 1.2 二分查找的特点

- **时间复杂度**：O(log n)
- **空间复杂度**：O(1)
- **前提条件**：数组必须有序
- **适用场景**：查找、插入位置、查找边界等

**示例**：
```
在升序数组 [1, 3, 5, 7, 9] 中查找 5：

初始：left=0, right=4, mid=2
nums[2]=5 == target，找到！

如果查找 4：
初始：left=0, right=4, mid=2
nums[2]=5 > 4，在左半边
更新：left=0, right=1, mid=0
nums[0]=1 < 4，在右半边
更新：left=1, right=1, mid=1
nums[1]=3 < 4，在右半边
更新：left=2, right=1，left>right，未找到
```

### 1.3 二分查找的核心思想

**核心思想**：
- 每次取查找范围的中点，比较中点元素和目标值
- 如果相等，则找到目标值
- 如果中点元素大于目标值，则目标值在左半边
- 如果中点元素小于目标值，则目标值在右半边
- 重复上述过程，直到找到目标值或搜索范围为空

## 2. 二分查找的两种写法

### 2.1 左闭右闭 [left, right]

**区间定义**：`[left, right]`，左右边界都包含在内

**关键点**：
- `right = nums.size() - 1`：右边界是最后一个有效索引
- `while (left <= right)`：因为左右都闭，`left == right` 是有意义的
- `right = mid - 1`：因为 `nums[mid]` 已经判断过，所以排除 `mid`
- `left = mid + 1`：同样排除 `mid`

**模板代码**：
```cpp
// LeetCode 704. 二分查找
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;  // 右边界是最后一个有效索引
        
        while (left <= right) {  // 因为左右都闭，所以left==right是有意义的
            int mid = left + (right - left) / 2;  // 防止溢出
            int num = nums[mid];
            
            if (num == target) {
                return mid;  // 找到了
            } else if (num > target) {
                right = mid - 1;  // 在左半边，排除mid
            } else {
                left = mid + 1;  // 在右半边，排除mid
            }
        }
        
        return -1;  // 没找到
    }
};
```

**关键点**：
- `mid = left + (right - left) / 2`：防止溢出，等价于 `(left + right) / 2`
- `right = mid - 1`：因为 `nums[mid]` 已经判断过，所以排除
- `left = mid + 1`：同样排除 `mid`

### 2.2 左闭右开 [left, right)

**区间定义**：`[left, right)`，左边界包含，右边界不包含

**关键点**：
- `right = nums.size()`：右边界是数组长度（不包含）
- `while (left < right)`：因为右开，`left == right` 是无效空间
- `right = mid`：因为 `right` 不包含，所以 `mid` 不需要减1
- `left = mid + 1`：左边界包含，所以需要加1

**模板代码**：
```cpp
// LeetCode 704. 二分查找（左闭右开写法）
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size();  // 右边界是数组长度（不包含）
        
        while (left < right) {  // 因为右开，left==right是无效空间
            int mid = left + ((right - left) >> 1);  // 使用右移，等价于除以2
            int num = nums[mid];
            
            if (num == target) {
                return mid;  // 找到了
            } else if (num > target) {
                right = mid;  // 在左区间，在[left, middle)中
            } else {
                left = mid + 1;  // 在右区间，在[middle+1, right)中
            }
        }
        
        return -1;  // 没找到
    }
};
```

**关键点**：
- `right = mid`：因为右边界不包含，所以不需要减1
- `left = mid + 1`：左边界包含，所以需要加1
- `(right - left) >> 1`：右移一位等价于除以2，性能更好

### 2.3 两种写法的对比

| 特性 | 左闭右闭 [left, right] | 左闭右开 [left, right) |
|:----:|:---------------------:|:---------------------:|
| **right初始值** | `nums.size() - 1` | `nums.size()` |
| **循环条件** | `left <= right` | `left < right` |
| **right更新** | `right = mid - 1` | `right = mid` |
| **left更新** | `left = mid + 1` | `left = mid + 1` |
| **适用场景** | 通用，推荐使用 | 某些边界问题更简洁 |

**建议**：
- **推荐使用左闭右闭**：更直观，不容易出错
- 两种写法都要掌握：根据题目选择最合适的写法

## 3. 基础应用模板

### 3.1 搜索插入位置

**适用场景**：在有序数组中查找目标值，如果不存在则返回应该插入的位置

**核心思路**：
- 使用二分查找
- 如果找到目标值，直接返回索引
- 如果没找到，返回 `right + 1`（左闭右闭）或 `right`（左闭右开）

**模板代码（左闭右闭）**：
```cpp
// LeetCode 35. 搜索插入位置
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        // 分别处理如下四种情况：
        // 1. 目标值在数组所有元素之前  [0, -1]
        // 2. 目标值等于数组中某一个元素  return middle;
        // 3. 目标值插入数组中的位置 [left, right]，return right + 1
        // 4. 目标值在数组所有元素之后的情况 [left, right]，因为是右闭区间，所以return right + 1
        return right + 1;
    }
};
```

**模板代码（左闭右开）**：
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0;
        int right = n;  // 定义target在左闭右开的区间里，[left, right)
        
        while (left < right) {  // 因为left == right的时候，在[left, right)是无效的空间
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle;  // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1;  // target 在右区间，在 [middle+1, right)中
            } else {
                return middle;  // 数组中找到目标值的情况，直接返回下标
            }
        }
        
        // 分别处理如下四种情况：
        // 1. 目标值在数组所有元素之前 [0,0)
        // 2. 目标值等于数组中某一个元素 return middle
        // 3. 目标值插入数组中的位置 [left, right) ，return right 即可
        // 4. 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right
        return right;
    }
};
```

**关键点**：
- 左闭右闭：返回 `right + 1`
- 左闭右开：返回 `right`

## 4. 查找边界问题

### 4.1 在排序数组中查找元素的第一个和最后一个位置

**适用场景**：在非递减数组中查找目标值的第一个和最后一个位置

**核心思路**：
- 分别查找左边界和右边界
- 左边界：找到第一个大于等于目标值的位置
- 右边界：找到第一个大于目标值的位置

**模板代码**：
```cpp
// LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        
        // 情况一：target 在数组范围的右边或者左边
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三：target 在数组范围中，且数组中存在target
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二：target 在数组范围中，且数组中不存在target
        return {-1, -1};
    }
    
private:
    // 寻找左边界：target 在 [nums] 的左边
    int getLeftBorder(vector<int>& nums, int target) {
        int leftBorder = -2;  // 记录一下leftBorder没有被赋值的情况
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 在右边，说明左边没有出现过target
                left = mid + 1;
            } else {
                // 在左边，或者相等，重点的找第一次出现的位置
                right = mid - 1;
                leftBorder = right;
            }
        }
        return leftBorder;
    }
    
    // 寻找右边界：[nums] target 在右边
    int getRightBorder(vector<int>& nums, int target) {
        int rightBorder = -2;  // 记录一下rightBorder没有被赋值的情况
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                // 在左边
                right = mid - 1;
            } else {
                // 在右边，或者相等，只关注于最右边的target
                left = mid + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
};
```

**关键点**：
- **左边界**：`nums[mid] >= target` 时，继续向左搜索，记录 `right`
- **右边界**：`nums[mid] <= target` 时，继续向右搜索，记录 `left`
- **边界值**：左边界返回 `leftBorder + 1`，右边界返回 `rightBorder - 1`

### 4.2 查找左边界（简化版）

**适用场景**：查找第一个大于等于目标值的位置

**模板代码**：
```cpp
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int leftBorder = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid - 1;
            leftBorder = mid;  // 记录可能的位置
        } else {
            left = mid + 1;
        }
    }
    
    return leftBorder;
}
```

### 4.3 查找右边界（简化版）

**适用场景**：查找最后一个小于等于目标值的位置

**模板代码**：
```cpp
int getRightBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    int rightBorder = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
            rightBorder = mid;  // 记录可能的位置
        } else {
            right = mid - 1;
        }
    }
    
    return rightBorder;
}
```

## 5. 旋转数组模板

### 5.1 搜索旋转排序数组

**适用场景**：在旋转后的有序数组中查找目标值

**核心思路**：
- 旋转数组的特点：至少有一半是有序的
- 判断左半部分还是右半部分有序
- 根据目标值是否在有序部分来决定搜索方向

**模板代码**：
```cpp
// LeetCode 33. 搜索旋转排序数组
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if (n == 0) return -1;
        
        int left = 0;
        int right = n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            
            // 左半部分有序
            if (nums[left] <= nums[mid]) {
                // 目标值在左半部分的有序区间内
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            // 右半部分有序
            else {
                // 目标值在右半部分的有序区间内
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
};
```

**关键点**：
- 判断有序部分：`nums[left] <= nums[mid]` 表示左半部分有序
- 目标值在有序区间：`nums[left] <= target && target < nums[mid]`
- 否则在另一部分搜索

### 5.2 寻找排序数组中的最小值

**适用场景**：在旋转后的有序数组中寻找最小值

**核心思路**：
- 使用左闭右开区间
- 比较 `nums[mid]` 和 `nums[right]`
- 如果 `nums[mid] > nums[right]`，最小值在右半部分
- 否则最小值在左半部分（包含mid）

**模板代码**：
```cpp
// LeetCode 153. 寻找排序数组中的最小值
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                // 最小值在右半部分
                left = mid + 1;
            } else {
                // 最小值在左半部分（包含mid）
                right = mid;
            }
        }
        
        return nums[left];
    }
};
```

**关键点**：
- 使用左闭右开：`while (left < right)`
- 比较中点与右端点：`nums[mid] > nums[right]`
- 右边界更新：`right = mid`（因为mid可能是最小值）

## 6. 二维矩阵模板

### 6.1 搜索二维矩阵

**适用场景**：在有序二维矩阵中查找目标值（每行从左到右递增，下一行第一个数大于上一行最后一个数）

**核心思路**：
- 将二维矩阵看作一维数组
- 使用坐标转换：`row = mid / n`，`col = mid % n`

**模板代码**：
```cpp
// LeetCode 74. 搜索二维矩阵
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false;
        
        int m = matrix.size();
        int n = matrix[0].size();
        
        int left = 0;
        int right = m * n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 坐标转换：将一维索引转换为二维坐标
            int value = matrix[mid / n][mid % n];
            
            if (value == target) {
                return true;
            } else if (value < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
};
```

**关键点**：
- 坐标转换：`row = mid / n`，`col = mid % n`
- 将二维矩阵看作一维数组进行二分查找
- 时间复杂度：O(log(mn))

## 7. 数学应用模板

### 7.1 X的平方根

**适用场景**：计算非负整数的平方根，结果向下取整

**核心思路**：
- 在 [0, x] 范围内二分查找
- 找到最大的 mid，使得 `mid * mid <= x`

**模板代码**：
```cpp
// LeetCode 69. X的平方根
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        if (x == 1) return 1;
        
        int left = 0;
        int right = x;
        int ans = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // 使用long long防止溢出
            if ((long long)mid * mid <= x) {
                ans = mid;
                left = mid + 1;  // 继续向右搜索，找更大的
            } else {
                right = mid - 1;
            }
        }
        
        return ans;
    }
};
```

**关键点**：
- 使用 `long long` 防止 `mid * mid` 溢出
- 找到满足条件的最大值：`mid * mid <= x` 时继续向右搜索

### 7.2 有效的完全平方数

**适用场景**：判断一个数是否是完全平方数

**核心思路**：
- 在 [0, num] 范围内二分查找
- 如果存在 mid 使得 `mid * mid == num`，则是完全平方数

**模板代码**：
```cpp
// LeetCode 367. 有效的完全平方数
class Solution {
public:
    bool isPerfectSquare(int num) {
        long left = 0;
        long right = num;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;
            
            if (square < num) {
                left = mid + 1;
            } else if (square > num) {
                right = mid - 1;
            } else {
                return true;  // 找到了
            }
        }
        
        return false;  // 没找到
    }
};
```

**关键点**：
- 使用 `long` 防止溢出
- 找到即返回 `true`，否则返回 `false`

### 7.3 寻找两个正序数组的中位数

**适用场景**：合并两个有序数组，找到中位数

**核心思路**：
- 方法1：合并两个数组后找中位数（简单但时间复杂度高）
- 方法2：使用二分查找优化（推荐）

**模板代码（方法1：合并后查找）**：
```cpp
// LeetCode 4. 寻找两个正序数组的中位数（方法1）
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums;
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        nums.insert(nums.end(), nums2.begin(), nums2.end());
        
        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        if (n % 2 == 1) {
            return nums[n / 2];
        } else {
            return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;
        }
    }
};
```

**关键点**：
- 合并两个数组：`nums.insert(nums.end(), nums1.begin(), nums1.end())`
- 排序后找中位数：奇数个返回中间值，偶数个返回中间两个数的平均值
- 时间复杂度：O((m+n)log(m+n))，空间复杂度：O(m+n)

**注意**：更优的解法是使用二分查找，时间复杂度为O(log(min(m,n)))，但实现较复杂。

## 8. 二分查找的时间复杂度

### 8.1 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|:----:|:---------:|:----:|
| **查找元素** | O(log n) | 每次搜索范围缩小一半 |
| **查找边界** | O(log n) | 需要两次二分查找 |
| **插入位置** | O(log n) | 一次二分查找 |

**推导过程**：
- 每次搜索范围缩小一半：n → n/2 → n/4 → ... → 1
- 搜索次数 k：n / 2^k = 1，所以 k = log₂n
- 时间复杂度：O(log n)

### 8.2 空间复杂度分析

| 写法 | 空间复杂度 | 说明 |
|:----:|:---------:|:----:|
| **迭代实现** | O(1) | 只使用常数额外空间 |
| **递归实现** | O(log n) | 递归栈的深度 |

**注意**：
- 二分查找通常使用迭代实现，空间复杂度为 O(1)
- 递归实现虽然代码简洁，但空间复杂度较高

## 9. 何时使用二分查找

### 9.1 使用场景

1. **有序数组查找**
   - 在有序数组中查找特定元素
   - 查找插入位置

2. **查找边界**
   - 查找第一个/最后一个满足条件的位置
   - 查找目标值的范围

3. **数学问题**
   - 平方根、立方根等
   - 满足某种条件的最大值/最小值

4. **旋转数组**
   - 在旋转有序数组中查找
   - 查找旋转点

5. **二维矩阵**
   - 在有序二维矩阵中查找
   - 每行/每列有序的矩阵

### 9.2 判断标准

**当遇到以下情况时，考虑使用二分查找**：
- 数组是有序的（或可以转化为有序）
- 需要 O(log n) 时间复杂度的查找
- 查找满足某种条件的边界
- 查找最大值/最小值

**示例**：
```cpp
// 问题：在有序数组中查找目标值

// 二分查找解法：O(log n)
int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

## 10. 二分查找的优缺点

### 10.1 优点

- **时间复杂度低**：O(log n)，比线性查找 O(n) 快得多
- **空间复杂度低**：O(1)，只需要常数额外空间
- **实现简单**：代码简洁，逻辑清晰
- **适用面广**：可以解决多种查找问题

### 10.2 缺点

- **前提条件**：数组必须有序
- **不适合动态数据**：如果数据频繁插入删除，维护有序性成本高
- **不适合链表**：链表不支持随机访问，无法使用二分查找

## 11. 常见题型总结

### 11.1 基础查找类

1. **二分查找**
   - 704.二分查找：在有序数组中查找目标值

2. **搜索插入位置**
   - 35.搜索插入位置：查找目标值或插入位置

### 11.2 边界查找类

1. **查找范围**
   - 34.在排序数组中查找元素的第一个和最后一个位置：查找目标值的左右边界

### 11.3 数学应用类

1. **平方根问题**
   - 69.X的平方根：计算平方根
   - 367.有效的完全平方数：判断是否是完全平方数

### 11.4 旋转数组类

1. **旋转数组查找**
   - 33.搜索旋转排序数组：在旋转数组中查找目标值
   - 81.搜索旋转排序数组II：有重复元素的旋转数组

2. **寻找旋转数组最小值**
   - 153.寻找排序数组中的最小值：寻找旋转数组的最小值

### 11.5 二维矩阵类

1. **有序矩阵查找**
   - 74.搜索二维矩阵：在有序二维矩阵中查找
   - 240.搜索二维矩阵II：每行每列有序的矩阵

### 11.6 其他应用类

1. **中位数问题**
   - 4.寻找两个正序数组的中位数：合并两个有序数组找中位数

## 12. 常见错误和注意事项

### 12.1 常见错误

1. **区间定义不清**
   - 错误：混用左闭右闭和左闭右开
   - 解决：明确区间定义，统一使用一种写法

2. **边界更新错误**
   - 错误：`right = mid`（左闭右闭）或 `right = mid - 1`（左闭右开）
   - 解决：根据区间定义正确更新边界

3. **溢出问题**
   - 错误：`mid = (left + right) / 2` 可能溢出
   - 解决：使用 `mid = left + (right - left) / 2`

4. **循环条件错误**
   - 错误：左闭右闭使用 `left < right`
   - 解决：根据区间定义选择正确的循环条件

### 12.2 注意事项

1. **防止溢出**
   ```cpp
   // 错误：可能溢出
   int mid = (left + right) / 2;
   
   // 正确：防止溢出
   int mid = left + (right - left) / 2;
   ```

2. **明确区间定义**
   - 左闭右闭：`right = nums.size() - 1`，`while (left <= right)`
   - 左闭右开：`right = nums.size()`，`while (left < right)`

3. **边界更新**
   - 左闭右闭：`right = mid - 1`，`left = mid + 1`
   - 左闭右开：`right = mid`，`left = mid + 1`

## 13. 总结

二分查找是一种高效的搜索算法，适用于有序数组中的查找问题。

**核心要点**：
1. **两种写法**：左闭右闭和左闭右开，推荐使用左闭右闭
2. **核心思想**：每次缩小一半搜索范围
3. **时间复杂度**：O(log n)
4. **空间复杂度**：O(1)（迭代实现）
5. **前提条件**：数组必须有序

**使用建议**：
- 掌握两种写法，根据题目选择最合适的
- 注意防止溢出：使用 `left + (right - left) / 2`
- 明确区间定义，正确更新边界
- 理解查找边界的技巧
- 注意处理边界情况和特殊情况

**常见题型总结**：
- **基础查找类**：二分查找、搜索插入位置
- **边界查找类**：查找第一个/最后一个位置
- **数学应用类**：平方根、完全平方数
- **旋转数组类**：搜索旋转排序数组、寻找旋转数组最小值
- **二维矩阵类**：搜索二维矩阵
- **其他应用类**：寻找两个正序数组的中位数

