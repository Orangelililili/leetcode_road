# 双指针理论基础

## 1. 双指针的基本概念

**双指针（Two Pointers）**是一种常用的算法技巧，通过使用两个指针在数组或字符串中按照一定规则移动，从而高效地解决问题。

### 1.1 基本术语
- **快指针（Fast Pointer）**：移动速度较快的指针，通常用于遍历或寻找元素
- **慢指针（Slow Pointer）**：移动速度较慢的指针，通常用于记录有效位置
- **左指针（Left Pointer）**：从数组左侧开始的指针
- **右指针（Right Pointer）**：从数组右侧开始的指针
- **滑动窗口（Sliding Window）**：双指针的一种特殊应用，维护一个动态的窗口区间

### 1.2 双指针的特点
- **降低时间复杂度**：通常可以将O(n²)优化到O(n)
- **空间复杂度低**：通常只需要O(1)的额外空间
- **代码简洁**：逻辑清晰，易于实现

**示例**：
```
数组：[1, 2, 3, 4, 5]

快慢指针（同向）：
slow → 1, 2, 3, 4, 5
fast → 1, 2, 3, 4, 5

左右指针（相向）：
left → 1, 2, 3, 4, 5 ← right
```

## 2. 双指针的分类

### 2.1 快慢指针（同向双指针）

**特点**：
- 两个指针从同一侧开始，移动速度不同
- 快指针用于遍历，慢指针用于记录有效位置
- **适用场景**：移除元素、删除重复项、判断链表是否有环

**示例**：
```cpp
// 移除元素：快指针遍历，慢指针记录新数组位置
int slow = 0;
for(int fast = 0; fast < nums.size(); fast++) {
    if(nums[fast] != val) {
        nums[slow] = nums[fast];
        slow++;
    }
}
```

### 2.2 左右指针（相向双指针）

**特点**：
- 两个指针分别从数组两端开始，向中间移动
- 根据条件决定移动哪个指针
- **适用场景**：反转字符串、有序数组的平方、两数之和、三数之和

**示例**：
```cpp
// 反转字符串：左右指针交换元素
int left = 0, right = s.size() - 1;
while(left < right) {
    swap(s[left], s[right]);
    left++;
    right--;
}
```

### 2.3 滑动窗口

**特点**：
- 维护一个动态的窗口区间
- 通过移动窗口的左右边界来解决问题
- **适用场景**：长度最小的子数组、水果成篮、无重复字符的最长子串

**示例**：
```cpp
// 滑动窗口：维护一个满足条件的窗口
int left = 0;
for(int right = 0; right < nums.size(); right++) {
    // 扩大窗口
    // 缩小窗口直到满足条件
    while(/* 不满足条件 */) {
        left++;
    }
}
```

## 3. 快慢指针模板

### 3.1 移除元素

**适用场景**：在数组中移除指定元素，要求原地修改

**核心思路**：
- 快指针遍历数组，寻找不等于目标值的元素
- 慢指针记录新数组的位置
- 将快指针找到的有效元素赋值给慢指针位置

**模板代码**：
```cpp
// LeetCode 27. 移除元素
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;  // 慢指针：新数组的下标
        
        // 快指针遍历数组
        for(int fast = 0; fast < nums.size(); fast++) {
            // 如果快指针指向的元素不等于目标值
            if(nums[fast] != val) {
                nums[slow] = nums[fast];  // 赋值给慢指针位置
                slow++;  // 慢指针后移
            }
        }
        
        return slow;  // 返回新数组的长度
    }
};
```

**关键点**：
- 快指针：遍历原数组，寻找有效元素
- 慢指针：记录新数组的位置
- 时间复杂度：O(n)，空间复杂度：O(1)

### 3.2 删除有序数组中的重复项

**适用场景**：删除有序数组中的重复项，要求原地修改

**核心思路**：
- 快指针遍历数组，寻找不重复的元素
- 慢指针记录新数组的位置
- 比较快指针当前元素和下一个元素，如果不相等则加入新数组

**模板代码**：
```cpp
// LeetCode 26. 删除有序数组中的重复项
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 1;  // 慢指针：新数组的下标，从1开始（第一个元素肯定不重复）
        
        // 快指针遍历到倒数第二个元素
        for(int fast = 0; fast < nums.size() - 1; fast++) {
            // 如果当前元素和下一个元素不相等
            if(nums[fast] != nums[fast + 1]) {
                nums[slow] = nums[fast + 1];  // 将下一个元素加入新数组
                slow++;  // 慢指针后移
            }
        }
        
        return slow;  // 返回新数组的长度
    }
};
```

**关键点**：
- 慢指针从1开始：第一个元素肯定不重复
- 快指针遍历到倒数第二个：需要比较fast和fast+1
- 比较条件：`nums[fast] != nums[fast + 1]`

### 3.3 移动零

**适用场景**：将数组中的所有0移动到数组末尾，保持非零元素的相对顺序

**核心思路**：
- 使用快慢指针移除所有0（类似移除元素）
- 然后将慢指针之后的位置全部置为0

**模板代码**：
```cpp
// LeetCode 283. 移动零
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        
        // 第一步：移除所有0（类似移除元素）
        for(int fast = 0; fast < nums.size(); fast++) {
            if(nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        
        // 第二步：将慢指针之后的位置全部置为0
        while(slow < nums.size()) {
            nums[slow] = 0;
            slow++;
        }
    }
};
```

**关键点**：
- 两步操作：先移除0，再补0
- 时间复杂度：O(n)，空间复杂度：O(1)

## 4. 左右指针模板

### 4.1 反转字符串

**适用场景**：反转字符数组或字符串

**核心思路**：
- 左指针从开头，右指针从末尾
- 交换左右指针指向的元素
- 左右指针向中间移动

**模板代码**：
```cpp
// LeetCode 344. 反转字符串
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size() - 1;
        
        while(left < right) {
            swap(s[left], s[right]);
            left++;
            right--;
        }
    }
};
```

**关键点**：
- 循环条件：`left < right`
- 交换后：左右指针同时移动
- 时间复杂度：O(n)，空间复杂度：O(1)

### 4.2 有序数组的平方

**适用场景**：给定一个非递减顺序的整数数组，返回每个数字的平方组成的新数组，要求也按非递减顺序排序

**核心思路**：
- 由于原数组有序，平方后最大值在两端
- 使用左右指针从两端向中间移动
- 比较左右指针指向元素的平方，将较大的放入结果数组末尾

**模板代码**：
```cpp
// LeetCode 977. 有序数组的平方
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> result(nums.size());
        int k = nums.size() - 1;  // 结果数组的最后一个位置
        
        int left = 0;
        int right = nums.size() - 1;
        
        // 从两端向中间移动
        while(left <= right) {
            // 比较左右指针指向元素的平方
            if(nums[left] * nums[left] > nums[right] * nums[right]) {
                result[k] = nums[left] * nums[left];
                k--;
                left++;
            } else {
                result[k] = nums[right] * nums[right];
                k--;
                right--;
            }
        }
        
        return result;
    }
};
```

**关键点**：
- 从大到小填充：结果数组从末尾开始填充
- 比较平方值：`nums[left] * nums[left]` vs `nums[right] * nums[right]`
- 循环条件：`left <= right`（包含等于，因为最后一个元素也要处理）

### 4.3 三数之和

**适用场景**：在数组中找到所有不重复的三元组，使得三个数的和为0

**核心思路**：
- 先排序
- 固定第一个数，使用左右指针找后两个数
- 关键：去重逻辑要正确

**模板代码**：
```cpp
// LeetCode 15. 三数之和
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        
        for(int i = 0; i < nums.size(); i++) {
            // 剪枝：如果第一个数大于0，后面不可能和为0
            if(nums[i] > 0) {
                return result;
            }
            
            // 去重a：正确方法，与前面的数比较
            if(i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            int left = i + 1;
            int right = nums.size() - 1;
            
            while(left < right) {
                if(nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if(nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    
                    // 去重b和c：找到答案后再去重
                    while(left < right && nums[right] == nums[right - 1]) right--;
                    while(left < right && nums[left] == nums[left + 1]) left++;
                    
                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }
        }
        
        return result;
    }
};
```

**关键点**：
- 去重a：`i > 0 && nums[i] == nums[i - 1]`（与前面的数比较）
- 去重b和c：找到答案后再去重，避免漏掉如[0,0,0]的情况
- 剪枝：如果第一个数大于0，直接返回
- 时间复杂度：O(n²)，空间复杂度：O(1)

### 4.4 四数之和

**适用场景**：在数组中找到所有不重复的四元组，使得四个数的和等于target

**核心思路**：
- 两层循环固定前两个数
- 使用左右指针找后两个数
- 注意剪枝和去重

**模板代码**：
```cpp
// LeetCode 18. 四数之和
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        
        for(int k = 0; k < nums.size(); k++) {
            // 一级剪枝
            if(nums[k] > target && nums[k] >= 0) {
                break;
            }
            
            // 去重nums[k]
            if(k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            
            for(int i = k + 1; i < nums.size(); i++) {
                // 二级剪枝
                if(nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }
                
                // 去重nums[i]
                if(i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                
                int left = i + 1;
                int right = nums.size() - 1;
                
                while(left < right) {
                    // 注意：防止溢出
                    if((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    } else if((long) nums[k] + nums[i] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        
                        // 去重nums[left]和nums[right]
                        while(left < right && nums[right] == nums[right - 1]) right--;
                        while(left < right && nums[left] == nums[left + 1]) left++;
                        
                        right--;
                        left++;
                    }
                }
            }
        }
        
        return result;
    }
};
```

**关键点**：
- 两层循环：外层固定k，内层固定i
- 剪枝：一级剪枝和二级剪枝
- 溢出处理：使用long防止int溢出
- 去重：对k、i、left、right都要去重
- 时间复杂度：O(n³)，空间复杂度：O(1)

## 5. 滑动窗口模板

### 5.1 长度最小的子数组

**适用场景**：找到数组中和大于等于target的长度最小的连续子数组

**核心思路**：
- 使用滑动窗口维护一个连续子数组
- 右指针扩大窗口，左指针缩小窗口
- 当窗口和大于等于target时，更新最小长度

**模板代码**：
```cpp
// LeetCode 209. 长度最小的子数组
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = INT32_MAX;  // 结果初始化为最大值
        int sum = 0;  // 滑动窗口数值之和
        int left = 0;  // 滑动窗口起始位置
        
        // 右指针扩大窗口
        for(int right = 0; right < nums.size(); right++) {
            sum += nums[right];  // 扩大窗口
            
            // 当窗口和大于等于target时，缩小窗口
            while(sum >= target) {
                int subLength = right - left + 1;  // 窗口长度
                result = result < subLength ? result : subLength;  // 更新最小长度
                sum -= nums[left];  // 缩小窗口
                left++;  // 左指针右移
            }
        }
        
        return result == INT32_MAX ? 0 : result;  // 如果没更新就返回0
    }
};
```

**关键点**：
- 右指针扩大窗口：`sum += nums[right]`
- 左指针缩小窗口：`sum -= nums[left]`
- 窗口长度：`right - left + 1`
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.2 滑动窗口通用模板

**核心思路**：
- 右指针扩大窗口，直到满足条件
- 左指针缩小窗口，直到不满足条件
- 在窗口满足条件时更新结果

**通用模板**：
```cpp
int left = 0, right = 0;

while(right < nums.size()) {
    // 扩大窗口
    // 更新窗口状态
    
    // 当窗口满足条件时
    while(/* 窗口满足条件 */) {
        // 更新结果
        // 缩小窗口
        left++;
    }
    
    right++;
}
```

## 6. 其他双指针技巧

### 6.1 比较含退格的字符串（反向双指针）

**适用场景**：比较两个字符串，其中'#'表示退格字符

**核心思路**：
- 从后往前遍历，使用双指针
- 遇到'#'时，记录需要跳过的字符数
- 跳过被退格的字符，找到实际有效的字符进行比较

**模板代码**：
```cpp
// LeetCode 844. 比较含退格的字符串
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int skipS = 0, skipT = 0;  // 记录需要跳过的字符数
        int i = s.length() - 1;
        int j = t.length() - 1;
        
        while(i >= 0 || j >= 0) {
            // 处理字符串s
            while(i >= 0) {
                if(s[i] == '#') {
                    skipS++;
                    i--;
                } else if(skipS > 0) {
                    skipS--;
                    i--;
                } else {
                    break;  // 找到有效字符
                }
            }
            
            // 处理字符串t
            while(j >= 0) {
                if(t[j] == '#') {
                    skipT++;
                    j--;
                } else if(skipT > 0) {
                    skipT--;
                    j--;
                } else {
                    break;  // 找到有效字符
                }
            }
            
            // 比较有效字符
            if(i >= 0 && j >= 0) {
                if(s[i] != t[j]) {
                    return false;
                }
            } else {
                // 如果一个字符串已经结束而另一个没有，它们不相等
                if(i >= 0 || j >= 0) {
                    return false;
                }
            }
            
            i--;
            j--;
        }
        
        return true;
    }
};
```

**关键点**：
- 反向遍历：从后往前处理
- 跳过逻辑：遇到'#'时skip++，遇到普通字符且skip>0时skip--
- 时间复杂度：O(n)，空间复杂度：O(1)

## 7. 双指针的时间复杂度

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|:----:|:---------:|:---------:|:----:|
| **快慢指针** | O(n) | O(1) | 一次遍历完成 |
| **左右指针** | O(n) | O(1) | 两个指针向中间移动 |
| **滑动窗口** | O(n) | O(1) | 每个元素最多被访问两次 |
| **三数之和** | O(n²) | O(1) | 外层循环+双指针 |
| **四数之和** | O(n³) | O(1) | 两层循环+双指针 |

**注意**：
- 双指针通常可以将暴力解法的O(n²)优化到O(n)
- 空间复杂度通常为O(1)，不需要额外的数据结构
- 滑动窗口虽然看起来是两层循环，但每个元素最多被访问两次，所以是O(n)

## 8. 何时使用双指针

### 8.1 使用场景

1. **数组操作**
   - 移除元素、删除重复项
   - 移动元素位置
   - 反转数组

2. **查找问题**
   - 有序数组的查找
   - 两数之和、三数之和、四数之和
   - 回文串判断

3. **子数组/子串问题**
   - 长度最小的子数组
   - 无重复字符的最长子串
   - 滑动窗口最大值

4. **字符串操作**
   - 反转字符串
   - 比较字符串（含特殊字符）

### 8.2 判断标准

**当遇到以下情况时，考虑使用双指针**：
- 需要原地修改数组
- 需要降低时间复杂度（从O(n²)到O(n)）
- 数组或字符串有序
- 需要维护一个动态的窗口区间
- 需要从两端向中间处理

**示例**：
```cpp
// 问题：移除数组中的指定元素

// 暴力解法：O(n²)
for(int i = 0; i < size; i++) {
    if(nums[i] == val) {
        for(int j = i + 1; j < size; j++) {
            nums[j - 1] = nums[j];
        }
    }
}

// 双指针解法：O(n)
int slow = 0;
for(int fast = 0; fast < nums.size(); fast++) {
    if(nums[fast] != val) {
        nums[slow] = nums[fast];
        slow++;
    }
}
```

## 9. 双指针的优缺点

### 9.1 优点
- **时间复杂度低**：通常可以将O(n²)优化到O(n)
- **空间复杂度低**：通常只需要O(1)的额外空间
- **代码简洁**：逻辑清晰，易于实现和理解
- **适用场景广**：可以解决多种类型的问题

### 9.2 缺点
- **需要数组有序**：某些问题（如三数之和）需要先排序
- **逻辑复杂**：某些问题（如滑动窗口）的边界条件需要仔细处理
- **不适用于所有问题**：某些问题不适合用双指针解决

## 10. 总结

双指针是一种高效的算法技巧，通过使用两个指针在数组或字符串中按照一定规则移动，可以高效地解决多种问题。

**核心要点**：
1. **三种类型**：快慢指针、左右指针、滑动窗口
2. **快慢指针**：用于移除元素、删除重复项等数组操作
3. **左右指针**：用于反转、查找、多数和等问题
4. **滑动窗口**：用于子数组、子串等连续区间问题
5. **时间复杂度**：通常为O(n)，空间复杂度为O(1)

**使用建议**：
- 数组操作类问题优先考虑快慢指针
- 有序数组的查找问题考虑左右指针
- 连续子数组/子串问题考虑滑动窗口
- 注意边界条件和去重逻辑
- 合理使用剪枝优化性能

**常见题型总结**：
- **快慢指针**：移除元素、删除重复项、移动零
- **左右指针**：反转字符串、有序数组的平方、三数之和、四数之和
- **滑动窗口**：长度最小的子数组、水果成篮
- **其他技巧**：比较含退格的字符串（反向双指针）

