[toc]
# 链表理论基础

## 1. 链表的基本概念

**链表（Linked List）**是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。

### 1.1 基本术语
- **节点（Node）**：链表中的基本单位，包含数据和指针
- **头节点（Head）**：链表的第一个节点
- **尾节点（Tail）**：链表的最后一个节点，其next指针为nullptr
- **虚拟头节点（Dummy Head）**：不存储数据的辅助节点，用于简化操作
- **单向链表**：每个节点只有一个指向下一个节点的指针
- **双向链表**：每个节点有两个指针，分别指向前一个和后一个节点

### 1.2 链表的特点
- **动态内存**：节点在内存中不连续存储
- **灵活大小**：可以动态添加和删除节点
- **插入删除快**：在已知位置插入或删除节点的时间复杂度为O(1)
- **访问慢**：访问第i个节点需要O(i)时间

**示例**：
```
单向链表：
head → [1|next] → [2|next] → [3|next] → nullptr

双向链表：
nullptr ← [prev|1|next] ↔ [prev|2|next] ↔ [prev|3|next] → nullptr
```

### 1.3 链表节点的定义

**C++中的链表节点定义**：
```cpp
// 单向链表节点
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

## 2. 链表的分类

### 2.1 单向链表（Singly Linked List）

**特点**：
- 每个节点只有一个指向下一个节点的指针
- 只能从头节点开始遍历
- 插入和删除操作相对简单

**示例**：
```cpp
// 创建链表: 1 -> 2 -> 3
ListNode* head = new ListNode(1);
head->next = new ListNode(2);
head->next->next = new ListNode(3);
```

### 2.2 双向链表（Doubly Linked List）

**特点**：
- 每个节点有两个指针：prev和next
- 可以从任意方向遍历
- 插入和删除操作需要维护两个指针

**示例**：
```cpp
// 双向链表节点
struct DListNode {
    int val;
    DListNode *prev;
    DListNode *next;
    DListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};
```

## 3. 虚拟头节点（Dummy Head）

### 3.1 虚拟头节点的作用

**虚拟头节点**是一个不存储有效数据的辅助节点，其next指针指向真正的头节点。

**优点**：
- **统一操作**：处理头节点和中间节点的方法一致
- **简化代码**：不需要特殊处理头节点的情况
- **避免空指针**：减少边界条件的判断

**示例**：
```cpp
// 不使用虚拟头节点：需要特殊处理头节点
if(head->val == val) {
    head = head->next;  // 特殊处理
}

// 使用虚拟头节点：统一处理
ListNode* dummyHead = new ListNode(0);
dummyHead->next = head;
// 所有节点都可以用相同的方法处理
```

### 3.2 虚拟头节点的使用模板

**模板代码**：
```cpp
ListNode* dummyHead = new ListNode(0);  // 创建虚拟头节点
dummyHead->next = head;                 // 指向真正的头节点
ListNode* cur = dummyHead;              // 从虚拟头节点开始遍历

// 进行操作...

head = dummyHead->next;  // 更新头节点
delete dummyHead;         // 释放虚拟头节点
return head;
```

## 4. 链表的基本操作模板

### 4.1 移除链表元素

**适用场景**：删除链表中所有值等于指定值的节点

**核心思路**：
- 使用虚拟头节点统一处理
- 遍历链表，删除值等于目标值的节点
- 注意：单向链表只能通过前一个节点删除当前节点

**模板代码**：
```cpp
// LeetCode 203. 移除链表元素
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 设置虚拟头节点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        
        // 遍历链表
        while(cur->next != nullptr) {
            if(cur->next->val == val) {
                // 删除节点
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;  // 释放内存
            } else {
                cur = cur->next;  // 移动到下一个节点
            }
        }
        
        head = dummyHead->next;
        delete dummyHead;  // 释放虚拟头节点
        return head;
    }
};
```

**关键点**：
- 使用虚拟头节点：统一处理头节点和中间节点
- 操作cur->next：单向链表只能通过前一个节点操作
- 内存管理：记得释放删除的节点和虚拟头节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 4.2 设计链表

**适用场景**：实现一个完整的链表类，支持增删改查操作

**核心思路**：
- 使用虚拟头节点简化操作
- 维护链表大小_size
- 实现基本的增删改查操作

#### 模板1：单向链表实现

**模板代码**：
```cpp
// LeetCode 707. 设计链表（单向链表）
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val) : val(val), next(nullptr) {}
    };

    MyLinkedList() {
        _dummyHead = new LinkedNode(0);  // 虚拟头节点
        _size = 0;                       // 记录链表节点个数
    }
    
    // 获取第index个节点的数值
    int get(int index) {
        if(index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    // 在链表最前面插入一个节点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }
    
    // 在链表最后面插入一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr) {
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }
    
    // 在第index个节点之前插入值为val的节点
    void addAtIndex(int index, int val) {
        if(index > _size) return;
        if(index < 0) index = 0;
        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }
    
    // 删除第index个节点
    void deleteAtIndex(int index) {
        if(index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

private:
    int _size;
    LinkedNode* _dummyHead;
};
```

**关键点**：
- 虚拟头节点：简化所有操作
- 维护_size：方便边界检查
- 内存管理：记得释放删除的节点

#### 模板2：双向链表实现

**模板代码**：
```cpp
// LeetCode 707. 设计链表（双向链表）
class MyLinkedList {
public:
    // 定义双向链表节点结构体
    struct DList {
        int elem;
        DList *next;
        DList *prev;
        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {}
    };

    MyLinkedList() {
        sentinelNode = new DList(0);  // 哨兵节点
        sentinelNode->next = sentinelNode;  // 形成循环
        sentinelNode->prev = sentinelNode;
        size = 0;
    }

    int get(int index) {
        if(index > (size - 1) || index < 0) {
            return -1;
        }
        // 根据索引位置选择从前往后或从后往前遍历
        int mid = size >> 1;
        DList *curNode = sentinelNode;
        if(index < mid) {
            for(int i = 0; i < index + 1; i++) {
                curNode = curNode->next;
            }
        } else {
            for(int i = 0; i < size - index; i++) {
                curNode = curNode->prev;
            }
        }
        return curNode->elem;
    }

    void addAtHead(int val) {
        DList *newNode = new DList(val);
        DList *next = sentinelNode->next;
        newNode->prev = sentinelNode;
        newNode->next = next;
        sentinelNode->next = newNode;
        next->prev = newNode;
        size++;
    }

    void addAtTail(int val) {
        DList *newNode = new DList(val);
        DList *prev = sentinelNode->prev;
        newNode->next = sentinelNode;
        newNode->prev = prev;
        sentinelNode->prev = newNode;
        prev->next = newNode;
        size++;
    }

    void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index <= 0) {
            addAtHead(val);
            return;
        }
        // 类似get操作，找到插入位置
        // ...（省略具体实现）
        size++;
    }

    void deleteAtIndex(int index) {
        if(index > (size - 1) || index < 0) {
            return;
        }
        // 类似get操作，找到删除位置
        // ...（省略具体实现）
        size--;
    }

private:
    int size;
    DList *sentinelNode;  // 哨兵节点（循环双向链表）
};
```

**关键点**：
- 循环双向链表：使用哨兵节点形成循环
- 双向遍历：可以根据索引位置选择遍历方向
- 维护两个指针：插入和删除需要同时维护prev和next

## 5. 链表的进阶操作模板

### 5.1 反转链表

**适用场景**：将链表反转

**核心思路**：
- 使用双指针：pre和cur
- 逐个反转节点的next指针
- 注意保存下一个节点

**模板代码**：
```cpp
// LeetCode 206. 反转链表
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp;      // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = nullptr;
        
        while(cur != nullptr) {
            temp = cur->next;  // 保存下一个节点
            cur->next = pre;   // 反转操作
            // 更新pre和cur指针
            pre = cur;
            cur = temp;
        }
        
        return pre;  // pre指向新的头节点
    }
};
```

**关键点**：
- 双指针：pre和cur
- 保存temp：在反转前保存下一个节点
- 返回pre：反转后pre指向新的头节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.2 两两交换链表中的节点

**适用场景**：将链表中每两个相邻的节点进行交换

**核心思路**：
- 使用虚拟头节点
- 每次交换两个节点
- 需要保存临时节点

**模板代码**：
```cpp
// LeetCode 24. 两两交换链表中的节点
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 虚拟头节点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        
        // 检查是否至少有一对节点
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next;              // 记录第一个节点
            ListNode* tmp1 = cur->next->next->next; // 记录第三个节点
            
            cur->next = cur->next->next;           // 步骤一：cur指向第二个节点
            cur->next->next = tmp;                  // 步骤二：第二个节点指向第一个节点
            cur->next->next->next = tmp1;          // 步骤三：第一个节点指向第三个节点
            
            cur = cur->next->next;  // cur移动两位，准备下一轮交换
        }
        
        ListNode* result = dummyHead->next;
        delete dummyHead;
        return result;
    }
};
```

**关键点**：
- 虚拟头节点：统一处理
- 保存临时节点：tmp和tmp1
- 三步交换：注意指针的指向顺序
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.3 删除链表的倒数第N个节点

**适用场景**：删除链表中倒数第n个节点

**核心思路**：
- 使用快慢指针
- 快指针先走n+1步
- 然后快慢指针同时移动，直到快指针到达末尾
- 此时慢指针指向要删除节点的前一个节点

**模板代码**：
```cpp
// LeetCode 19. 删除链表的倒数第N个节点
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        
        // 快指针先走n+1步
        while(n-- && fast != nullptr) {
            fast = fast->next;
        }
        fast = fast->next;  // fast再提前走一步，让slow指向删除节点的上一个节点
        
        // 快慢指针同时移动
        while(fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        
        // 删除节点
        slow->next = slow->next->next;
        
        return dummyHead->next;
    }
};
```

**关键点**：
- 虚拟头节点：处理删除头节点的情况
- 快慢指针：快指针先走n+1步
- 慢指针位置：指向要删除节点的前一个节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.4 链表相交

**适用场景**：找到两个链表的相交节点

**核心思路**：
- 计算两个链表的长度
- 让较长的链表先走长度差步
- 然后两个指针同时移动，找到相交节点

**模板代码**：
```cpp
// LeetCode 面试题 02.07. 链表相交
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        
        // 计算链表A的长度
        while(curA != nullptr) {
            lenA++;
            curA = curA->next;
        }
        
        // 计算链表B的长度
        while(curB != nullptr) {
            lenB++;
            curB = curB->next;
        }
        
        curA = headA;
        curB = headB;
        
        // 让curA为最长链表的头，lenA为其长度
        if(lenB > lenA) {
            swap(lenA, lenB);
            swap(curA, curB);
        }
        
        // 让curA先走长度差步
        int gap = lenA - lenB;
        while(gap--) {
            curA = curA->next;
        }
        
        // 两个指针同时移动，找到相交节点
        while(curA != nullptr) {
            if(curA == curB) {  // 注意：比较的是指针，不是值
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        
        return nullptr;
    }
};
```

**关键点**：
- 计算长度：分别遍历两个链表
- 对齐操作：让较长的链表先走长度差步
- 指针比较：比较的是指针地址，不是节点的值
- 时间复杂度：O(n + m)，空间复杂度：O(1)

### 5.5 环形链表II

**适用场景**：判断链表是否有环，并找到环的入口

**核心思路**：
- 使用快慢指针判断是否有环
- 如果有环，找到相遇点后，一个指针从头开始，一个从相遇点开始
- 两个指针同时移动，相遇点就是环的入口

**模板代码**：
```cpp
// LeetCode 142. 环形链表II
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        
        // 判断是否有环
        while(fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;  // 快指针走两步
            slow = slow->next;        // 慢指针走一步
            if(slow == fast) {         // 相遇，说明有环
                // 找环的入口
                ListNode* index1 = fast;  // 从相遇点开始
                ListNode* index2 = head;   // 从头节点开始
                while(index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2;  // 返回环的入口
            }
        }
        
        return nullptr;  // 无环
    }
};
```

**关键点**：
- 快慢指针：快指针走两步，慢指针走一步
- 相遇判断：如果相遇，说明有环
- 找入口：一个从头开始，一个从相遇点开始，同时移动
- 时间复杂度：O(n)，空间复杂度：O(1)

**原理说明**：
```
假设：
- 从头节点到环入口的距离为a
- 环的长度为b
- 快慢指针相遇时，慢指针走了a + c步，快指针走了a + c + nb步

因为快指针速度是慢指针的2倍：
2(a + c) = a + c + nb
a + c = nb
a = nb - c

所以，从头节点走a步，从相遇点走nb-c步，会在环入口相遇。
```

## 6. 链表操作的时间复杂度

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|:----:|:---------:|:---------:|:----:|
| **访问第i个节点** | O(i) | O(1) | 需要从头遍历 |
| **在头部插入** | O(1) | O(1) | 直接插入 |
| **在尾部插入** | O(n) | O(1) | 需要遍历到尾部 |
| **在中间插入** | O(i) | O(1) | 需要遍历到位置i |
| **删除节点** | O(i) | O(1) | 需要遍历到位置i |
| **反转链表** | O(n) | O(1) | 需要遍历所有节点 |
| **查找环** | O(n) | O(1) | 快慢指针 |

**注意**：
- 链表的随机访问是O(i)，不如数组的O(1)
- 链表的插入和删除在已知位置时是O(1)，但需要先找到位置
- 虚拟头节点可以简化操作，但需要额外的O(1)空间

## 7. 何时使用链表技巧

### 7.1 使用场景

1. **需要频繁插入删除**
   - 链表在已知位置插入删除的时间复杂度为O(1)
   - 适合动态大小的数据结构

2. **不需要随机访问**
   - 如果不需要通过索引快速访问元素
   - 链表可以节省内存（不需要连续内存）

3. **需要反转或交换**
   - 链表的反转和节点交换相对简单
   - 只需要改变指针指向

4. **需要判断环或相交**
   - 快慢指针可以高效判断环
   - 双指针可以找到相交节点

### 7.2 判断标准

**当遇到以下情况时，考虑使用链表技巧**：
- 需要频繁插入删除 → 使用链表
- 需要反转链表 → 使用双指针
- 需要删除倒数第n个节点 → 使用快慢指针
- 需要判断环 → 使用快慢指针
- 需要统一处理头节点 → 使用虚拟头节点

**示例**：
```cpp
// 问题：删除链表中所有值等于val的节点

// 不使用虚拟头节点：需要特殊处理
if(head->val == val) {
    head = head->next;  // 特殊处理头节点
}
// 然后处理其他节点...

// 使用虚拟头节点：统一处理
ListNode* dummyHead = new ListNode(0);
dummyHead->next = head;
// 所有节点都可以用相同的方法处理
```

## 8. 链表的优缺点

### 8.1 优点
- **动态大小**：可以动态添加和删除节点
- **插入删除快**：在已知位置插入删除的时间复杂度为O(1)
- **内存灵活**：不需要连续的内存空间
- **反转简单**：只需要改变指针指向

### 8.2 缺点
- **访问慢**：访问第i个节点需要O(i)时间
- **内存开销**：每个节点需要额外的指针空间
- **不能随机访问**：不能像数组一样通过索引直接访问
- **缓存不友好**：节点不连续，缓存命中率低

## 9. 常见题型总结

### 9.1 基本操作类

1. **移除链表元素**
   - 使用虚拟头节点统一处理
   - 注意内存管理

2. **设计链表**
   - 实现完整的链表类
   - 支持增删改查操作

### 9.2 反转和交换类

1. **反转链表**
   - 使用双指针逐个反转
   - 注意保存下一个节点

2. **两两交换链表中的节点**
   - 使用虚拟头节点
   - 注意保存临时节点

### 9.3 快慢指针类

1. **删除链表的倒数第N个节点**
   - 快指针先走n+1步
   - 然后快慢指针同时移动

2. **环形链表II**
   - 快慢指针判断环
   - 找到环的入口

### 9.4 双指针类

1. **链表相交**
   - 计算长度并对齐
   - 两个指针同时移动

## 10. 总结

链表是一种重要的线性数据结构，掌握链表的基本操作和常用技巧对于解决算法问题至关重要。

**核心要点**：
1. **虚拟头节点**：统一处理头节点和中间节点，简化代码
2. **双指针**：用于反转、交换、删除等操作
3. **快慢指针**：用于删除倒数节点、判断环等
4. **内存管理**：记得释放删除的节点和虚拟头节点
5. **时间复杂度**：访问O(i)，插入删除O(1)（已知位置）

**使用建议**：
- 需要统一处理头节点时使用虚拟头节点
- 需要反转或交换时使用双指针
- 需要删除倒数节点或判断环时使用快慢指针
- 注意内存管理，避免内存泄漏
- 理解指针操作，注意边界条件

**常见题型总结**：
- **基本操作类**：移除链表元素、设计链表
- **反转和交换类**：反转链表、两两交换链表中的节点
- **快慢指针类**：删除链表的倒数第N个节点、环形链表II
- **双指针类**：链表相交

