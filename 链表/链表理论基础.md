[toc]
# 链表理论基础

## 1. 链表的基本概念

**链表（Linked List）**是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。

### 1.1 基本术语
- **节点（Node）**：链表中的基本单位，包含数据和指针
- **头节点（Head）**：链表的第一个节点
- **尾节点（Tail）**：链表的最后一个节点，其next指针为nullptr
- **虚拟头节点（Dummy Head）**：不存储数据的辅助节点，用于简化操作
- **单向链表**：每个节点只有一个指向下一个节点的指针
- **双向链表**：每个节点有两个指针，分别指向前一个和后一个节点

### 1.2 链表的特点
- **动态内存**：节点在内存中不连续存储
- **灵活大小**：可以动态添加和删除节点
- **插入删除快**：在已知位置插入或删除节点的时间复杂度为O(1)
- **访问慢**：访问第i个节点需要O(i)时间

**示例**：
```
单向链表：
head → [1|next] → [2|next] → [3|next] → nullptr

双向链表：
nullptr ← [prev|1|next] ↔ [prev|2|next] ↔ [prev|3|next] → nullptr
```

### 1.3 链表节点的定义

**C++中的链表节点定义**：
```cpp
// 单向链表节点
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

## 2. 链表的分类

### 2.1 单向链表（Singly Linked List）

**特点**：
- 每个节点只有一个指向下一个节点的指针
- 只能从头节点开始遍历
- 插入和删除操作相对简单

**示例**：
```cpp
// 创建链表: 1 -> 2 -> 3
ListNode* head = new ListNode(1);
head->next = new ListNode(2);
head->next->next = new ListNode(3);
```

### 2.2 双向链表（Doubly Linked List）

**特点**：
- 每个节点有两个指针：prev和next
- 可以从任意方向遍历
- 插入和删除操作需要维护两个指针

**示例**：
```cpp
// 双向链表节点
struct DListNode {
    int val;
    DListNode *prev;
    DListNode *next;
    DListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};
```

## 3. 虚拟头节点（Dummy Head）

### 3.1 虚拟头节点的作用

**虚拟头节点**是一个不存储有效数据的辅助节点，其next指针指向真正的头节点。

**优点**：
- **统一操作**：处理头节点和中间节点的方法一致
- **简化代码**：不需要特殊处理头节点的情况
- **避免空指针**：减少边界条件的判断

**示例**：
```cpp
// 不使用虚拟头节点：需要特殊处理头节点
if(head->val == val) {
    head = head->next;  // 特殊处理
}

// 使用虚拟头节点：统一处理
ListNode* dummyHead = new ListNode(0);
dummyHead->next = head;
// 所有节点都可以用相同的方法处理
```

### 3.2 虚拟头节点的使用模板

**模板代码**：
```cpp
ListNode* dummyHead = new ListNode(0);  // 创建虚拟头节点
dummyHead->next = head;                 // 指向真正的头节点
ListNode* cur = dummyHead;              // 从虚拟头节点开始遍历

// 进行操作...

head = dummyHead->next;  // 更新头节点
delete dummyHead;         // 释放虚拟头节点
return head;
```

## 4. 链表的基本操作模板

### 4.1 移除链表元素

**适用场景**：删除链表中所有值等于指定值的节点

**核心思路**：
- 使用虚拟头节点统一处理
- 遍历链表，删除值等于目标值的节点
- 注意：单向链表只能通过前一个节点删除当前节点

**模板代码**：
```cpp
// LeetCode 203. 移除链表元素
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 设置虚拟头节点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        
        // 遍历链表
        while(cur->next != nullptr) {
            if(cur->next->val == val) {
                // 删除节点
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;  // 释放内存
            } else {
                cur = cur->next;  // 移动到下一个节点
            }
        }
        
        head = dummyHead->next;
        delete dummyHead;  // 释放虚拟头节点
        return head;
    }
};
```

**关键点**：
- 使用虚拟头节点：统一处理头节点和中间节点
- 操作cur->next：单向链表只能通过前一个节点操作
- 内存管理：记得释放删除的节点和虚拟头节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 4.2 设计链表

**适用场景**：实现一个完整的链表类，支持增删改查操作

**核心思路**：
- 使用虚拟头节点简化操作
- 维护链表大小_size
- 实现基本的增删改查操作

#### 模板1：单向链表实现

**模板代码**：
```cpp
// LeetCode 707. 设计链表（单向链表）
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val) : val(val), next(nullptr) {}
    };

    MyLinkedList() {
        _dummyHead = new LinkedNode(0);  // 虚拟头节点
        _size = 0;                       // 记录链表节点个数
    }
    
    // 获取第index个节点的数值
    int get(int index) {
        if(index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--) {
            cur = cur->next;
        }
        return cur->val;
    }
    
    // 在链表最前面插入一个节点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }
    
    // 在链表最后面插入一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr) {
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }
    
    // 在第index个节点之前插入值为val的节点
    void addAtIndex(int index, int val) {
        if(index > _size) return;
        if(index < 0) index = 0;
        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }
    
    // 删除第index个节点
    void deleteAtIndex(int index) {
        if(index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

private:
    int _size;
    LinkedNode* _dummyHead;
};
```

**关键点**：
- 虚拟头节点：简化所有操作
- 维护_size：方便边界检查
- 内存管理：记得释放删除的节点

#### 模板2：双向链表实现

**模板代码**：
```cpp
// LeetCode 707. 设计链表（双向链表）
class MyLinkedList {
public:
    // 定义双向链表节点结构体
    struct DList {
        int elem;
        DList *next;
        DList *prev;
        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {}
    };

    MyLinkedList() {
        sentinelNode = new DList(0);  // 哨兵节点
        sentinelNode->next = sentinelNode;  // 形成循环
        sentinelNode->prev = sentinelNode;
        size = 0;
    }

    int get(int index) {
        if(index > (size - 1) || index < 0) {
            return -1;
        }
        // 根据索引位置选择从前往后或从后往前遍历
        int mid = size >> 1;
        DList *curNode = sentinelNode;
        if(index < mid) {
            for(int i = 0; i < index + 1; i++) {
                curNode = curNode->next;
            }
        } else {
            for(int i = 0; i < size - index; i++) {
                curNode = curNode->prev;
            }
        }
        return curNode->elem;
    }

    void addAtHead(int val) {
        DList *newNode = new DList(val);
        DList *next = sentinelNode->next;
        newNode->prev = sentinelNode;
        newNode->next = next;
        sentinelNode->next = newNode;
        next->prev = newNode;
        size++;
    }

    void addAtTail(int val) {
        DList *newNode = new DList(val);
        DList *prev = sentinelNode->prev;
        newNode->next = sentinelNode;
        newNode->prev = prev;
        sentinelNode->prev = newNode;
        prev->next = newNode;
        size++;
    }

    void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index <= 0) {
            addAtHead(val);
            return;
        }
        // 类似get操作，找到插入位置
        // ...（省略具体实现）
        size++;
    }

    void deleteAtIndex(int index) {
        if(index > (size - 1) || index < 0) {
            return;
        }
        // 类似get操作，找到删除位置
        // ...（省略具体实现）
        size--;
    }

private:
    int size;
    DList *sentinelNode;  // 哨兵节点（循环双向链表）
};
```

**关键点**：
- 循环双向链表：使用哨兵节点形成循环
- 双向遍历：可以根据索引位置选择遍历方向
- 维护两个指针：插入和删除需要同时维护prev和next

## 5. 链表的进阶操作模板

### 5.1 反转链表

**适用场景**：将链表反转

**核心思路**：
- 使用双指针：pre和cur
- 逐个反转节点的next指针
- 注意保存下一个节点

**模板代码**：
```cpp
// LeetCode 206. 反转链表
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp;      // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = nullptr;
        
        while(cur != nullptr) {
            temp = cur->next;  // 保存下一个节点
            cur->next = pre;   // 反转操作
            // 更新pre和cur指针
            pre = cur;
            cur = temp;
        }
        
        return pre;  // pre指向新的头节点
    }
};
```

**关键点**：
- 双指针：pre和cur
- 保存temp：在反转前保存下一个节点
- 返回pre：反转后pre指向新的头节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.2 两两交换链表中的节点

**适用场景**：将链表中每两个相邻的节点进行交换

**核心思路**：
- 使用虚拟头节点
- 每次交换两个节点
- 需要保存临时节点

**模板代码**：
```cpp
// LeetCode 24. 两两交换链表中的节点
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 虚拟头节点
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        
        // 检查是否至少有一对节点
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next;              // 记录第一个节点
            ListNode* tmp1 = cur->next->next->next; // 记录第三个节点
            
            cur->next = cur->next->next;           // 步骤一：cur指向第二个节点
            cur->next->next = tmp;                  // 步骤二：第二个节点指向第一个节点
            cur->next->next->next = tmp1;          // 步骤三：第一个节点指向第三个节点
            
            cur = cur->next->next;  // cur移动两位，准备下一轮交换
        }
        
        ListNode* result = dummyHead->next;
        delete dummyHead;
        return result;
    }
};
```

**关键点**：
- 虚拟头节点：统一处理
- 保存临时节点：tmp和tmp1
- 三步交换：注意指针的指向顺序
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.3 删除链表的倒数第N个节点

**适用场景**：删除链表中倒数第n个节点

**核心思路**：
- 使用快慢指针
- 快指针先走n+1步
- 然后快慢指针同时移动，直到快指针到达末尾
- 此时慢指针指向要删除节点的前一个节点

**模板代码**：
```cpp
// LeetCode 19. 删除链表的倒数第N个节点
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        
        // 快指针先走n+1步
        while(n-- && fast != nullptr) {
            fast = fast->next;
        }
        fast = fast->next;  // fast再提前走一步，让slow指向删除节点的上一个节点
        
        // 快慢指针同时移动
        while(fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        
        // 删除节点
        slow->next = slow->next->next;
        
        return dummyHead->next;
    }
};
```

**关键点**：
- 虚拟头节点：处理删除头节点的情况
- 快慢指针：快指针先走n+1步
- 慢指针位置：指向要删除节点的前一个节点
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.4 链表相交

**适用场景**：找到两个链表的相交节点

**核心思路**：
- 计算两个链表的长度
- 让较长的链表先走长度差步
- 然后两个指针同时移动，找到相交节点

**模板代码**：
```cpp
// LeetCode 面试题 02.07. 链表相交
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        
        // 计算链表A的长度
        while(curA != nullptr) {
            lenA++;
            curA = curA->next;
        }
        
        // 计算链表B的长度
        while(curB != nullptr) {
            lenB++;
            curB = curB->next;
        }
        
        curA = headA;
        curB = headB;
        
        // 让curA为最长链表的头，lenA为其长度
        if(lenB > lenA) {
            swap(lenA, lenB);
            swap(curA, curB);
        }
        
        // 让curA先走长度差步
        int gap = lenA - lenB;
        while(gap--) {
            curA = curA->next;
        }
        
        // 两个指针同时移动，找到相交节点
        while(curA != nullptr) {
            if(curA == curB) {  // 注意：比较的是指针，不是值
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        
        return nullptr;
    }
};
```

**关键点**：
- 计算长度：分别遍历两个链表
- 对齐操作：让较长的链表先走长度差步
- 指针比较：比较的是指针地址，不是节点的值
- 时间复杂度：O(n + m)，空间复杂度：O(1)

### 5.5 环形链表II

**适用场景**：判断链表是否有环，并找到环的入口

**核心思路**：
- 使用快慢指针判断是否有环
- 如果有环，找到相遇点后，一个指针从头开始，一个从相遇点开始
- 两个指针同时移动，相遇点就是环的入口

**模板代码**：
```cpp
// LeetCode 142. 环形链表II
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        
        // 判断是否有环
        while(fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;  // 快指针走两步
            slow = slow->next;        // 慢指针走一步
            if(slow == fast) {         // 相遇，说明有环
                // 找环的入口
                ListNode* index1 = fast;  // 从相遇点开始
                ListNode* index2 = head;   // 从头节点开始
                while(index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2;  // 返回环的入口
            }
        }
        
        return nullptr;  // 无环
    }
};
```

**关键点**：
- 快慢指针：快指针走两步，慢指针走一步
- 相遇判断：如果相遇，说明有环
- 找入口：一个从头开始，一个从相遇点开始，同时移动
- 时间复杂度：O(n)，空间复杂度：O(1)

**原理说明**：
```
假设：
- 从头节点到环入口的距离为a
- 环的长度为c
- 环入口到相遇点的距离为b
- 快慢指针相遇时，慢指针走了a + b步，快指针走了2(a + b)步

因为快指针速度是慢指针的2倍：
2(a + b) = a + b + kc  (k为快指针在环中绕的圈数)
a + b = kc
a = kc - b = (k-1)c + (c - b)

所以，从头节点走a步，从相遇点走(k-1)c + (c-b)步，会在环入口相遇。
```

### 5.6 环形链表（判断是否有环）

**适用场景**：判断链表中是否存在环

**核心思路**：
- 使用快慢指针
- 快指针走两步，慢指针走一步
- 如果相遇，说明有环；如果快指针到达末尾，说明无环

**模板代码**：
```cpp
// LeetCode 141. 环形链表
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 快慢指针
        ListNode* slow = head;
        ListNode* fast = head;
        
        while(fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;  // 快指针走两步
            slow = slow->next;        // 慢指针走一步
            
            if(fast == slow) {         // 相遇，说明有环
                return true;
            }
        }
        
        return false;  // 无环
    }
};
```

**关键点**：
- 快慢指针：快指针走两步，慢指针走一步
- 相遇判断：如果相遇，说明有环
- 终止条件：fast或fast->next为nullptr时，说明无环
- 时间复杂度：O(n)，空间复杂度：O(1)

### 5.7 回文链表

**适用场景**：判断链表是否为回文链表

**核心思路**：
- **方法1**：快慢指针找中点 + 反转后半段 + 比较
- **方法2**：将链表值复制到数组 + 双指针比较

#### 方法1：快慢指针 + 反转

**模板代码**：
```cpp
// LeetCode 234. 回文链表（方法1：快慢指针+反转）
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head || !head->next) return true;
        
        // 1. 快慢指针找中点
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        // 2. 反转后半段
        ListNode* prev = nullptr;
        ListNode* cur = slow;
        while(cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }
        
        // 3. 比较前后两段
        ListNode* left = head;
        ListNode* right = prev;
        while(right) {
            if(left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }
        
        return true;
    }
};
```

**关键点**：
- 快慢指针找中点：slow指向中点（或中点后一个）
- 反转后半段：使用双指针反转
- 比较：从两端向中间比较
- 时间复杂度：O(n)，空间复杂度：O(1)

#### 方法2：数组 + 双指针

**模板代码**：
```cpp
// LeetCode 234. 回文链表（方法2：数组+双指针）
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 把链表值复制到数组
        vector<int> vals;
        while(head != nullptr) {
            vals.emplace_back(head->val);
            head = head->next;
        }
        
        // 双指针对比
        for(int i = 0, j = vals.size() - 1; i < j; i++, j--) {
            if(vals[i] != vals[j]) return false;
        }
        return true;
    }
};
```

**关键点**：
- 数组存储：将链表值复制到数组
- 双指针比较：从两端向中间比较
- 时间复杂度：O(n)，空间复杂度：O(n)

### 5.8 合并两个有序链表

**适用场景**：将两个有序链表合并成一个有序链表

**核心思路**：
- 使用虚拟头节点
- 比较两个链表的当前节点值
- 将较小的节点连接到结果链表
- 处理剩余节点

**模板代码**：
```cpp
// LeetCode 21. 合并两个有序链表
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 虚拟头节点
        ListNode dummy(0);
        ListNode* cur = &dummy;
        
        // 比较两个链表的当前节点
        while(list1 && list2) {
            if(list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        
        // 处理剩余节点
        cur->next = list1 ? list1 : list2;
        
        return dummy.next;
    }
};
```

**关键点**：
- 虚拟头节点：简化操作
- 比较节点值：选择较小的节点
- 处理剩余：将剩余链表直接连接
- 时间复杂度：O(n + m)，空间复杂度：O(1)

### 5.9 两数相加

**适用场景**：两个链表表示的数字相加，返回结果链表

**核心思路**：
- 使用虚拟头节点
- 同时遍历两个链表
- 处理进位
- 注意链表长度不同和最后进位的情况

**模板代码**：
```cpp
// LeetCode 2. 两数相加
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        int carry = 0;  // 进位
        
        while(l1 || l2 || carry) {
            int sum = carry;
            
            if(l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2) {
                sum += l2->val;
                l2 = l2->next;
            }
            
            carry = sum / 10;  // 计算进位
            cur->next = new ListNode(sum % 10);  // 创建新节点
            cur = cur->next;
        }
        
        return dummy.next;
    }
};
```

**关键点**：
- 虚拟头节点：简化操作
- 处理进位：carry记录进位
- 循环条件：l1、l2或carry任一不为空就继续
- 时间复杂度：O(max(n, m))，空间复杂度：O(max(n, m))

### 5.10 K个一组翻转链表

**适用场景**：每k个节点一组进行翻转，如果节点总数不是k的整数倍，最后剩余的节点保持原有顺序

**核心思路**：
- **方法1**：递归反转 + 连接
- **方法2**：使用栈（更直观）

#### 方法1：递归反转

**模板代码**：
```cpp
// LeetCode 25. K个一组翻转链表（方法1：递归反转）
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode dummy(0);
        dummy.next = head;
        ListNode* prev = &dummy;
        
        while(true) {
            // 1. 找到这一组的尾巴
            ListNode* tail = prev;
            for(int i = 0; i < k; i++) {
                tail = tail->next;
                if(!tail) return dummy.next;  // 不足k个，直接返回
            }
            
            // 2. 记住下一组的头
            ListNode* nextGroupHead = tail->next;
            
            // 3. 反转这一组
            auto [newHead, newTail] = reverse(prev->next, tail);
            
            // 4. 接回原链表
            prev->next = newHead;
            newTail->next = nextGroupHead;
            
            // 5. prev前进，准备下一组
            prev = newTail;
        }
    }
    
private:
    // 反转从head到tail的链表
    pair<ListNode*, ListNode*> reverse(ListNode* head, ListNode* tail) {
        ListNode* prev = tail->next;  // 关键：prev初始化为tail->next
        ListNode* cur = head;
        
        while(prev != tail) {
            ListNode* temp = cur->next;
            cur->next = prev;
            prev = cur;
            cur = temp;
        }
        return {tail, head};  // 返回新头和新尾
    }
};
```

**关键点**：
- 分组处理：每次处理k个节点
- 反转函数：prev初始化为tail->next是关键
- 连接：将反转后的组接回原链表
- 时间复杂度：O(n)，空间复杂度：O(1)

#### 方法2：使用栈

**模板代码**：
```cpp
// LeetCode 25. K个一组翻转链表（方法2：使用栈）
ListNode* reverseKGroup(ListNode* head, int k) {
    stack<ListNode*> st;
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prev = &dummy;
    ListNode* cur = head;
    
    while(cur) {
        // 1. 入栈k个节点
        for(int i = 0; i < k; i++) {
            if(!cur) return dummy.next;  // 不足k个，直接返回
            st.push(cur);
            cur = cur->next;
        }
        
        // 2. 出栈并接回
        while(!st.empty()) {
            prev->next = st.top();
            st.pop();
            prev = prev->next;
        }
        
        // 3. 接回后续
        prev->next = cur;
    }
    
    return dummy.next;
}
```

**关键点**：
- 使用栈：将k个节点入栈，然后出栈实现反转
- 更直观：思路简单，易于理解
- 时间复杂度：O(n)，空间复杂度：O(k)

### 5.11 随机链表的复制

**适用场景**：复制一个包含随机指针的链表

**核心思路**：
- 使用哈希表存储原节点到新节点的映射
- 递归复制节点和随机指针
- 利用哈希表避免重复创建

**模板代码**：
```cpp
// LeetCode 138. 随机链表的复制
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;
    
    Node* copyRandomList(Node* head) {
        if(head == nullptr) {
            return nullptr;
        }
        
        // 如果已经复制过，直接返回
        if(!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            // 递归复制next和random
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        
        return cachedNode[head];
    }
};
```

**关键点**：
- 哈希表：存储原节点到新节点的映射
- 递归复制：递归复制next和random指针
- 避免重复：使用哈希表避免重复创建节点
- 时间复杂度：O(n)，空间复杂度：O(n)

### 5.12 排序链表

**适用场景**：对链表进行排序（要求O(nlogn)时间复杂度）

**核心思路**：
- 使用归并排序
- 快慢指针找中点，分割链表
- 递归排序，然后合并

**模板代码**：
```cpp
// LeetCode 148. 排序链表
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) {
            return head;
        }
        
        // 快慢指针找中点
        ListNode *slow = head, *fast = head, *prev = nullptr;
        while(fast && fast->next) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        
        prev->next = nullptr;  // 切成两段
        
        // 递归排序
        ListNode* l1 = sortList(head);
        ListNode* l2 = sortList(slow);
        
        // 合并
        return merge(l1, l2);
    }
    
private:
    ListNode* merge(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        
        while(l1 && l2) {
            if(l1->val > l2->val) {
                cur->next = l2;
                l2 = l2->next;
            } else {
                cur->next = l1;
                l1 = l1->next;
            }
            cur = cur->next;
        }
        
        cur->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

**关键点**：
- 归并排序：分治思想
- 快慢指针：找中点分割链表
- 递归合并：递归排序后合并
- 时间复杂度：O(nlogn)，空间复杂度：O(logn)（递归栈）

### 5.13 合并K个升序链表

**适用场景**：合并k个有序链表

**核心思路**：
- 使用分治合并
- 两两合并，逐步减少链表数量
- 类似归并排序的合并过程

**模板代码**：
```cpp
// LeetCode 23. 合并K个升序链表
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty()) return nullptr;
        
        int interval = 1;
        // 分治合并
        while(interval < lists.size()) {
            for(int i = 0; i + interval < lists.size(); i += interval * 2) {
                lists[i] = mergeTwoList(lists[i], lists[i + interval]);
            }
            interval *= 2;
        }
        
        return lists[0];
    }
    
private:
    ListNode* mergeTwoList(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        
        while(l1 && l2) {
            if(l1->val > l2->val) {
                cur->next = l2;
                l2 = l2->next;
            } else {
                cur->next = l1;
                l1 = l1->next;
            }
            cur = cur->next;
        }
        
        cur->next = l1 ? l1 : l2;
        return dummy.next;
    }
};
```

**关键点**：
- 分治合并：两两合并，逐步减少链表数量
- interval倍增：每次合并的间隔翻倍
- 时间复杂度：O(nklogk)，空间复杂度：O(1)

### 5.14 LRU缓存（双向链表 + 哈希表）

**适用场景**：实现LRU（最近最少使用）缓存

**核心思路**：
- 使用双向链表维护访问顺序
- 使用哈希表实现O(1)查找
- 最近使用的节点移到头部，最久未使用的在尾部

**模板代码**：
```cpp
// LeetCode 146. LRU缓存
struct Node {
    int key, value;
    Node* prev;
    Node* next;
    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    int capacity;
    unordered_map<int, Node*> cache;
    Node* head;  // 最近使用
    Node* tail;  // 最久未使用
    
    // 移动节点到头
    void moveToHead(Node* node) {
        if(node == head) return;
        
        // 先断开
        if(node->prev) node->prev->next = node->next;
        if(node->next) node->next->prev = node->prev;
        if(node == tail) tail = node->prev;
        
        // 插入到头
        node->next = head;
        node->prev = nullptr;
        if(head) head->prev = node;
        head = node;
        if(!tail) tail = head;
    }
    
    // 删除尾部节点
    void removeTail() {
        if(!tail) return;
        cache.erase(tail->key);
        Node* prev = tail->prev;
        delete tail;
        tail = prev;
        if(tail) tail->next = nullptr;
        else head = nullptr;
    }
    
public:
    LRUCache(int cap) {
        capacity = cap;
        head = nullptr;
        tail = nullptr;
    }
    
    int get(int key) {
        if(cache.find(key) == cache.end()) return -1;
        Node* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if(cache.find(key) != cache.end()) {
            // 更新已存在的节点
            Node* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            // 创建新节点
            Node* node = new Node(key, value);
            cache[key] = node;
            moveToHead(node);
            if(cache.size() > capacity) {
                removeTail();
            }
        }
    }
};
```

**关键点**：
- 双向链表：维护访问顺序
- 哈希表：实现O(1)查找
- moveToHead：将节点移到头部
- removeTail：删除尾部节点（最久未使用）
- 时间复杂度：get和put都是O(1)，空间复杂度：O(capacity)

## 6. 链表操作的时间复杂度

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|:----:|:---------:|:---------:|:----:|
| **访问第i个节点** | O(i) | O(1) | 需要从头遍历 |
| **在头部插入** | O(1) | O(1) | 直接插入 |
| **在尾部插入** | O(n) | O(1) | 需要遍历到尾部 |
| **在中间插入** | O(i) | O(1) | 需要遍历到位置i |
| **删除节点** | O(i) | O(1) | 需要遍历到位置i |
| **反转链表** | O(n) | O(1) | 需要遍历所有节点 |
| **查找环** | O(n) | O(1) | 快慢指针 |
| **合并两个有序链表** | O(n + m) | O(1) | 遍历两个链表 |
| **排序链表** | O(nlogn) | O(logn) | 归并排序（递归栈） |
| **合并K个链表** | O(nklogk) | O(1) | 分治合并 |
| **LRU缓存get/put** | O(1) | O(capacity) | 双向链表+哈希表 |

**注意**：
- 链表的随机访问是O(i)，不如数组的O(1)
- 链表的插入和删除在已知位置时是O(1)，但需要先找到位置
- 虚拟头节点可以简化操作，但需要额外的O(1)空间

## 7. 何时使用链表技巧

### 7.1 使用场景

1. **需要频繁插入删除**
   - 链表在已知位置插入删除的时间复杂度为O(1)
   - 适合动态大小的数据结构

2. **不需要随机访问**
   - 如果不需要通过索引快速访问元素
   - 链表可以节省内存（不需要连续内存）

3. **需要反转或交换**
   - 链表的反转和节点交换相对简单
   - 只需要改变指针指向

4. **需要判断环或相交**
   - 快慢指针可以高效判断环
   - 双指针可以找到相交节点

5. **需要合并或排序**
   - 合并有序链表使用双指针
   - 排序链表使用归并排序

6. **需要实现缓存**
   - LRU缓存使用双向链表+哈希表
   - 维护访问顺序

### 7.2 判断标准

**当遇到以下情况时，考虑使用链表技巧**：
- 需要频繁插入删除 → 使用链表
- 需要反转链表 → 使用双指针
- 需要删除倒数第n个节点 → 使用快慢指针
- 需要判断环 → 使用快慢指针
- 需要统一处理头节点 → 使用虚拟头节点
- 需要合并有序链表 → 使用双指针比较
- 需要排序链表 → 使用归并排序
- 需要实现LRU缓存 → 使用双向链表+哈希表
- 需要复制带随机指针的链表 → 使用哈希表+递归

**示例**：
```cpp
// 问题：删除链表中所有值等于val的节点

// 不使用虚拟头节点：需要特殊处理
if(head->val == val) {
    head = head->next;  // 特殊处理头节点
}
// 然后处理其他节点...

// 使用虚拟头节点：统一处理
ListNode* dummyHead = new ListNode(0);
dummyHead->next = head;
// 所有节点都可以用相同的方法处理
```

## 8. 链表的优缺点

### 8.1 优点
- **动态大小**：可以动态添加和删除节点
- **插入删除快**：在已知位置插入删除的时间复杂度为O(1)
- **内存灵活**：不需要连续的内存空间
- **反转简单**：只需要改变指针指向

### 8.2 缺点
- **访问慢**：访问第i个节点需要O(i)时间
- **内存开销**：每个节点需要额外的指针空间
- **不能随机访问**：不能像数组一样通过索引直接访问
- **缓存不友好**：节点不连续，缓存命中率低

## 9. 常见题型总结

### 9.1 基本操作类

1. **移除链表元素**
   - 使用虚拟头节点统一处理
   - 注意内存管理

2. **设计链表**
   - 实现完整的链表类
   - 支持增删改查操作

### 9.2 反转和交换类

1. **反转链表**
   - 使用双指针逐个反转
   - 注意保存下一个节点

2. **两两交换链表中的节点**
   - 使用虚拟头节点
   - 注意保存临时节点

### 9.3 快慢指针类

1. **删除链表的倒数第N个节点**
   - 快指针先走n+1步
   - 然后快慢指针同时移动

2. **环形链表**
   - 快慢指针判断是否有环
   - 时间复杂度O(n)

3. **环形链表II**
   - 快慢指针判断环
   - 找到环的入口

4. **回文链表**
   - 快慢指针找中点 + 反转后半段
   - 或使用数组+双指针

### 9.4 双指针类

1. **链表相交**
   - 计算长度并对齐
   - 两个指针同时移动

2. **合并两个有序链表**
   - 使用虚拟头节点
   - 比较节点值，选择较小的

3. **两数相加**
   - 处理进位
   - 注意链表长度不同

### 9.5 分组和反转类

1. **K个一组翻转链表**
   - 递归反转 + 连接
   - 或使用栈

### 9.6 排序和合并类

1. **排序链表**
   - 归并排序
   - 快慢指针找中点

2. **合并K个升序链表**
   - 分治合并
   - 两两合并

### 9.7 特殊结构类

1. **随机链表的复制**
   - 哈希表 + 递归
   - 避免重复创建节点

2. **LRU缓存**
   - 双向链表 + 哈希表
   - 维护访问顺序

## 10. 总结

链表是一种重要的线性数据结构，掌握链表的基本操作和常用技巧对于解决算法问题至关重要。

**核心要点**：
1. **虚拟头节点**：统一处理头节点和中间节点，简化代码
2. **双指针**：用于反转、交换、删除、合并等操作
3. **快慢指针**：用于删除倒数节点、判断环、找中点等
4. **分治思想**：用于排序链表、合并K个链表
5. **哈希表**：用于随机链表复制、LRU缓存等
6. **双向链表**：用于LRU缓存等需要双向遍历的场景
7. **内存管理**：记得释放删除的节点和虚拟头节点
8. **时间复杂度**：访问O(i)，插入删除O(1)（已知位置）

**使用建议**：
- 需要统一处理头节点时使用虚拟头节点
- 需要反转或交换时使用双指针
- 需要删除倒数节点或判断环时使用快慢指针
- 需要合并多个链表时考虑分治思想
- 需要快速查找时结合哈希表
- 需要维护访问顺序时使用双向链表
- 注意内存管理，避免内存泄漏
- 理解指针操作，注意边界条件

**常见题型总结**：
- **基本操作类**：移除链表元素、设计链表
- **反转和交换类**：反转链表、两两交换链表中的节点
- **快慢指针类**：删除链表的倒数第N个节点、环形链表、环形链表II、回文链表
- **双指针类**：链表相交、合并两个有序链表、两数相加
- **分组和反转类**：K个一组翻转链表
- **排序和合并类**：排序链表、合并K个升序链表
- **特殊结构类**：随机链表的复制、LRU缓存

