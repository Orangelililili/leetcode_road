# 图论理论基础

## 1. 图的基本概念

**图（Graph）**是由顶点（Vertex/Node）和边（Edge）组成的数据结构，用来表示事物之间的关系。

- **顶点（Vertex）**：图中的节点，表示事物
- **边（Edge）**：连接两个顶点的线，表示关系
- **路径（Path）**：从一个顶点到另一个顶点经过的边的序列
- **环（Cycle）**：起点和终点相同的路径

## 2. 图的种类

### 2.1 有向图 vs 无向图
- **无向图**：边没有方向，A-B 和 B-A 是同一条边
- **有向图**：边有方向，A→B 和 B→A 是不同的边

### 2.2 加权图
- **无权图**：边没有权重，只表示连接关系
- **加权图**：边有权重，表示距离、成本等

### 2.3 度（Degree）
- **度**：与顶点相连的边的数量
- **出度**：有向图中从顶点出发的边的数量
- **入度**：有向图中指向顶点的边的数量

## 3. 连通性

### 3.1 连通图 vs 非连通图
- **连通图**：任意两个顶点之间都存在路径
- **非连通图**：存在两个顶点之间没有路径

### 3.2 强连通性（有向图）
- **强连通图**：任意两个顶点之间都存在双向路径
- **强连通分量**：极大强连通子图

**例子**：
```
有向图：A → B → C → A
        ↓
        D

强连通分量1：{A, B, C} - 这三个节点互相可达
强连通分量2：{D} - 单独一个节点
```

**图解**：
```
A ──→ B ──→ C
│           │
│           │
└───────────┘
│
↓
D
```

### 3.3 连通分量
- **连通分量**：无向图中的极大连通子图
- **连通分量数量**：图中连通分量的个数

**例子**：
```
无向图：A-B-C, D-E, F

连通分量1：{A, B, C} - 这三个节点互相连通
连通分量2：{D, E} - 这两个节点互相连通  
连通分量3：{F} - 单独一个节点
连通分量数量：3
```

**图解**：
```
A ── B ── C    D ── E    F
```

## 4. 图的存储方式

### 4.1 邻接矩阵
```cpp
// 适合稠密图，空间复杂度O(V²)
vector<vector<int>> graph(V, vector<int>(V, 0));
// graph[i][j] = 1 表示顶点i和j之间有边
```

### 4.2 邻接表
```cpp
// 适合稀疏图，空间复杂度O(V+E)
vector<vector<int>> graph(V);
// graph[i] 存储与顶点i相邻的所有顶点
```

### 4.3 边列表
```cpp
// 存储所有边的信息
vector<pair<int, int>> edges;  // 无权边
vector<tuple<int, int, int>> edges;  // 加权边 (u, v, weight)
```

## 5. 图的遍历方式

### 5.1 深度优先搜索（DFS）
```cpp
void dfs(int node, vector<bool>& visited, vector<vector<int>>& graph) {
    visited[node] = true;  // 标记当前节点已访问
    
    // 遍历当前节点的所有邻居
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {  // 如果邻居未被访问
            dfs(neighbor, visited, graph);  // 递归访问邻居
        }
    }
}
```

**DFS特点**：
- **深度优先**：尽可能深地搜索图的分支
- **递归实现**：使用递归栈，代码简洁
- **应用场景**：路径查找、连通性判断、拓扑排序
- **时间复杂度**：O(V+E)，每个顶点和边访问一次
- **空间复杂度**：O(V)，递归栈的深度

**执行过程示例**：
```
图：A-B-C
    |   |
    D   E

DFS访问顺序：A → B → C → E → D
```

### 5.2 广度优先搜索（BFS）
```cpp
void bfs(int start, vector<vector<int>>& graph) {
    queue<int> q;  // 队列存储待访问的节点
    vector<bool> visited(graph.size(), false);  // 标记数组
    
    q.push(start);  // 将起始节点加入队列
    visited[start] = true;  // 标记起始节点已访问
    
    while (!q.empty()) {  // 队列不为空时继续
        int node = q.front();  // 取出队首节点
        q.pop();  // 从队列中移除
        
        // 遍历当前节点的所有邻居
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {  // 如果邻居未被访问
                visited[neighbor] = true;  // 标记邻居已访问
                q.push(neighbor);  // 将邻居加入队列
            }
        }
    }
}
```

**BFS特点**：
- **广度优先**：逐层访问，先访问距离近的节点
- **队列实现**：使用队列维护访问顺序
- **应用场景**：最短路径、层次遍历、连通性判断
- **时间复杂度**：O(V+E)，每个顶点和边访问一次
- **空间复杂度**：O(V)，队列的最大长度

**执行过程示例**：
```
图：A-B-C
    |   |
    D   E

BFS访问顺序：A → B → D → C → E
层次：第0层：A
     第1层：B, D
     第2层：C, E
```

## 6. 图论算法分类

### 6.1 图的存储与遍历
- **DFS/BFS**：基础遍历算法
- **应用**：岛屿数量、被围绕的区域

### 6.2 拓扑排序
- **Kahn算法**：基于入度的拓扑排序
- **DFS法**：基于深度优先搜索的拓扑排序
- **应用**：课程表、任务调度

### 6.3 并查集
- **Union-Find**：集合合并与查询
- **应用**：省份数量、朋友圈

### 6.4 最短路径算法
- **Dijkstra**：单源最短路径（非负权）
- **Bellman-Ford**：单源最短路径（可处理负权）
- **Floyd-Warshall**：多源最短路径

### 6.5 最小生成树
- **Kruskal**：基于边的贪心算法
- **Prim**：基于顶点的贪心算法

## 7. 时间复杂度总结

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| DFS/BFS | O(V+E) | O(V) | 图遍历 |
| 拓扑排序 | O(V+E) | O(V) | DAG排序 |
| 并查集 | O(α(n)) | O(V) | 连通性判断 |
| Dijkstra | O((V+E)logV) | O(V) | 单源最短路 |
| Floyd | O(V³) | O(V²) | 多源最短路 |
| Kruskal | O(ElogE) | O(V) | 最小生成树 |

## 8. dfs三部曲
## 8.1 dfs和bfs区别
| 比较项 | DFS（深度优先搜索） | BFS（广度优先搜索） |
|:------:|:------------------:|:------------------:|
| **搜索策略** | 一条路走到黑（递归/栈） | 一层一层扩展（队列） |
| **实现方式** | 通常用 **递归** 或 **显式栈** | 通常用 **队列（queue）** |
| **适用场景** | 适合 **全路径搜索、组合问题、回溯问题**（如图遍历、排列组合） | 适合 **最短路径问题、层次遍历**（如最短步数、层数搜索） |
| **空间复杂度** | 相对较小（与递归深度有关） | 相对较大（需存整层节点） |
| **典型应用** | 迷宫求解、图连通分量、全排列 | 最短路径、最少步数、层序遍历 |

## 8.2 dfs搜索过程
假设你在一个迷宫中：

1. 看到一个路口 → 选一条路走；
2. 走到底发现死路 → 返回上一个岔口；
3. 选另一条没走过的路 → 再次深入；
4. 最终找到所有可能的出口。

这整个过程就叫 **深度优先搜索（DFS）**。

## 8.3 代码框架

```cpp
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径

void dfs (参数){
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }

}
```


