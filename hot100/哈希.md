
1. 两数之和
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
//数组局限是要是元素很少，hash值过大会导致内存占用过大
//set是一个集合，里面只能发那个一个key
//所以要是现在需要下标，所以要用map

        //无所谓是否有序。
        unordered_map<int,int> umap;
        for(int i=0;i<nums.size();i++){
            auto ptr=umap.find(target-nums[i]);
            if(ptr!=umap.end()) return {ptr->second,i};
            
            //没有就把访问过的元素加入到map中，就相当于把之前的记录存到map，没必要循环两次
            umap.insert(pair<int,int>(nums[i],i));
        }

        return {};
    }
};

```

49. 字母异位词分组
```cpp

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;

        for (auto& s : strs) {
            int freq[26] = {0};
            for (char c : s) {
                freq[c - 'a']++;
            }

            // 把频次数组转成字符串作为key，例如："2#1#0#0#..."
            string key;
            for (int i = 0; i < 26; i++) {
                key += to_string(freq[i]);
                key.push_back('#');  // 避免歧义
            }

            mp[key].push_back(s);
        }

        vector<vector<string>> result;
        for (auto& p : mp) {
            result.push_back(p.second);
        }

        return result;
    }
};

```

128. 最长连续序列
```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        //O(n),就是遍历一遍
        int result=0;

        //用set去重，然后要是每次都从某个数目x进行向后查找，就要n方，
        //从某个数y向前，要是y-1存在，它就不是这个set最开始的数字
        unordered_set<int> uset;

        for(const int& num:nums){
            uset.insert(num);
        }

        for(const int& num:uset){
            if(!uset.count(num-1)){
                //那么这个数字就是最开始的数字
                int currentNum =num;
                int currentResult=1;

                while(uset.count(currentNum+1)){
                    currentNum+=1;
                    currentResult+=1;
                }

                result=max(currentResult,result);
            }
            
        }

        return result;
    }
};
```