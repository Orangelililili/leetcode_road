70爬楼梯
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```
118杨辉三角
```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result;

        for (int i = 0; i < numRows; i++) {
            // 创建第 i 行，长度是 i + 1
            vector<int> row(i + 1, 1);

            // 填充中间元素
            for (int j = 1; j < i; j++) {
                row[j] = result[i - 1][j - 1] + result[i - 1][j];
            }

            // 放入结果
            result.push_back(row);
        }

        return result;
    }
};

```
198打家劫舍
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        vector<int> dp(n, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);  //  修正点

        for (int i = 2; i < n; i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[n - 1];  //  不需要 result
    }
};

```
279完全平方数
```cpp
//完全背包问题，每个数使用次数无限制
class Solution {
public:
    int numSquares(int n) {

        /* ===============================
         * 1️ dp 数组含义
         * dp[i] 表示：凑成数字 i 所需要的「最少完全平方数个数」
         * 例如：
         * dp[12] = 3 （4 + 4 + 4）
         * dp[13] = 2 （9 + 4）
         * =============================== */
        vector<int> dp(n + 1, INT_MAX);

        /* ===============================
         * 2️ 初始化
         * dp[0] = 0：
         * 凑成 0 不需要任何平方数，这是所有递推的起点
         * =============================== */
        dp[0] = 0;

        /* ===============================
         * 3️ 迭代（遍历）顺序
         * 外层：枚举当前要凑的目标值 i（1 → n）
         * 内层：枚举可以选择的完全平方数 j*j
         * =============================== */
        for (int i = 1; i <= n; i++) {

            /* ===============================
             * 4️ 递推（状态转移）公式
             *
             * 如果最后一个使用的是平方数 j*j，
             * 那么之前一定已经凑出了 i - j*j
             *
             * dp[i] = min(
             *              dp[i], 
             *              dp[i - j*j] + 1
             *            )
             *
             * +1 表示「再使用一个平方数 j*j」
             * =============================== */
            for (int j = 1; j * j <= i; j++) {
                dp[i] = min(dp[i], dp[i - j * j] + 1);
            }
        }

        /* ===============================
         * 5️ 返回结果
         * dp[n] 就是凑成 n 的最少平方数个数
         * =============================== */
        return dp[n];
    }
};


```
322零钱兑换
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {

        /* =====================================
         * 1️ dp 数组含义
         *
         * dp[i] 表示：
         * 凑出金额 i 所需要的「最少硬币数量」
         *
         * 例如：
         * dp[11] = 3 （5 + 5 + 1）
         * ===================================== */
        vector<int> dp(amount + 1, INT_MAX);

        /* =====================================
         * 2️ 初始化
         *
         * dp[0] = 0：
         * 凑出金额 0 不需要任何硬币
         * 这是所有状态转移的起点
         * ===================================== */
        dp[0] = 0;

        /* =====================================
         * 3️ 迭代顺序
         *
         * 外层：当前目标金额 i（1 → amount）
         * 内层：枚举每一种硬币 coins[j]
         *
         * 因为「硬币可以无限使用」
         * 所以这是一个【完全背包】问题
         * ===================================== */
        for (int i = 1; i <= amount; i++) {

            /* =====================================
             * 4 状态转移（递推公式）
             *
             * 如果最后使用了一枚 coins[j]：
             * 那么之前一定已经凑出了 i - coins[j]
             *
             * dp[i] = min(
             *              dp[i],
             *              dp[i - coins[j]] + 1
             *            )
             *
             * +1 表示「再使用一枚硬币」
             *
             * 注意：
             * dp[i - coins[j]] 可能是 INT_MAX，
             * 说明该状态不可达，要跳过
             * ===================================== */
            for (int coin : coins) {
                if (i - coin >= 0 && dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        /* =====================================
         * 5️ 返回结果
         *
         * 如果 dp[amount] 仍然是 INT_MAX，
         * 说明无法凑出 amount，返回 -1
         * 否则返回 dp[amount]
         * ===================================== */
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};

```
139单词拆分
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        int n = s.size();

        /* =====================================
         * 1️ dp 数组含义
         * dp[i] 表示：
         * s 的前 i 个字符（s[0...i-1]）
         * 是否可以被 wordDict 中的单词拆分
         * ===================================== */
        vector<bool> dp(n + 1, false);

        /* =====================================
         * 2️ 初始化
         * dp[0] = true：
         * 空字符串是“可拆分”的
         * ===================================== */
        dp[0] = true;

        /* =====================================
         * 3️ 迭代顺序（完全背包）
         *
         * 外层：当前位置 i（0 → n-1）
         * 内层：枚举每个单词 word
         *
         * 每个单词可以重复使用
         * ===================================== */
        for (int i = 0; i < n; i++) {

            // 如果当前位置不可达，直接跳过
            if (!dp[i]) continue;

            /* =====================================
             * 4️ 状态转移
             * 尝试用 wordDict 中的单词去匹配 s[i ... ]
             * ===================================== */
            for (const string& word : wordDict) {
                int len = word.size();

                // 边界检查 + 子串匹配
                if (i + len <= n && s.substr(i, len) == word) {
                    dp[i + len] = true;
                }
            }
        }

        /* =====================================
         * 5️ 返回结果
         * ===================================== */
        return dp[n];
    }
};

```
300最长递增子序列
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;

        /* 
         * dp[i] 表示：
         * 以 nums[i] 结尾的「最长严格递增子序列长度」
         */
        vector<int> dp(n, 1);  // 初始化为 1：每个数自己都能构成长度为 1 的 LIS

        int result = 1;

        // 外层：枚举结尾位置 i
        for (int i = 0; i < n; i++) {

            // 内层：枚举 i 之前的所有位置 j
            for (int j = 0; j < i; j++) {

                // 如果 nums[i] 可以接在 nums[j] 后面
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            //举个具体例子nums = [3, 10, 2, 1, 20]，过一遍就理解了
            // 维护全局最大值
            result = max(result, dp[i]);
        }

        return result;
    }
};

```
152乘积最大子数组
```cpp
//负负得正，所以最大值可能来自于之前的最大值或者最小值乘以当前负数
//或者当前值是0，比如【-2，0】，最大值是当前值
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // maxDp[i]：以 nums[i] 结尾的最大乘积
        // minDp[i]：以 nums[i] 结尾的最小乘积
        vector<int> maxDp(n), minDp(n);

        // 初始化
        maxDp[0] = nums[0];
        minDp[0] = nums[0];

        int ans = nums[0];

        // 从第二个元素开始遍历
        for (int i = 1; i < n; i++) {
            // 先保存前一状态，避免被覆盖
            int prevMax = maxDp[i - 1];
            int prevMin = minDp[i - 1];

            // 三种情况取最大/最小
            maxDp[i] = max(nums[i], max(prevMax * nums[i], prevMin * nums[i]));
            minDp[i] = min(nums[i], min(prevMax * nums[i], prevMin * nums[i]));

            // 更新答案
            ans = max(ans, maxDp[i]);
        }

        return ans;
    }
};

```
416分割等和子集
```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;

        // 计算总和
        for (int num : nums) sum += num;

        // 总和为奇数，不可能分成两个相等子集
        if (sum % 2 != 0) return false;

        int target = sum / 2;

        // dp[i] 表示是否存在子集和为 i
        vector<bool> dp(target + 1, false);
        dp[0] = true; // 空集和为 0

        // 枚举每个数字
        for (int num : nums) {
            // 逆序遍历，保证每个数字只能用一次，01背包
            for (int i = target; i >= num; i--) {
                dp[i] = dp[i] || dp[i - num];
            }
        }

        return dp[target];
    }
};

```
32最长有效括号
```cpp
//栈顶保存当前有效括号 前一个位置
//遇到 ')' 弹出匹配的 '(' 下标
//有效长度 = 当前下标 - 栈顶下标
//如果栈空了，说明从哨兵到当前位置不再连续，更新哨兵
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        st.push(-1); // 哨兵
        int maxLen = 0;

        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                st.push(i);
            } else {
                st.pop();
                if (st.empty()) {
                    st.push(i); // 更新哨兵
                } else {
                    maxLen = max(maxLen, i - st.top());
                }
            }
        }

        return maxLen;
    }
};

```