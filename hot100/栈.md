20有效的括号
```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false;  // 奇数长度一定不匹配
        
        stack<char> st;
        
        for (int i = 0; i < s.size(); i++) {
            // 遇到左括号，将对应的右括号入栈
            if (s[i] == '(') st.push(')');
            else if (s[i] == '[') st.push(']');
            else if (s[i] == '{') st.push('}');
            // 遇到右括号，检查是否匹配
            else if (st.empty() || s[i] != st.top()) {
                return false;  // 不匹配或右括号多了
            } else {
                st.pop();  // 匹配，弹出
            }
        }
        
        return st.empty();  // 栈为空说明全部匹配
    }
};
```
155最小栈
```cpp
class MinStack {
private:
    stack<int> s;      // 正常栈
    stack<int> minS;   // 最小值栈

public:
    MinStack() {}

    void push(int val) {
        s.push(val);
        if (minS.empty() || val <= minS.top()) {
            minS.push(val);
        }
    }

    void pop() {
        if (s.top() == minS.top()) {
            minS.pop();
        }
        s.pop();
    }

    int top() {
        return s.top();
    }

    int getMin() {
        return minS.top();
    }
};

```
394字符串解码
```cpp
class Solution {
public:
    string decodeString(string s) {

        stack<int> countStack;      // 保存每一层的重复次数 k
        stack<string> stringStack;  // 保存进入 '[' 之前的字符串

        string curr = "";           // 当前正在构建的字符串
        int k = 0;                  // 当前层的重复次数（可能是多位数）

        // 从左到右扫描字符串
        for (char c : s) {

            // 1️ 如果是数字，构造多位数 k
            if (isdigit(c)) {
                // 例如 '1' -> '2'，构成 12
                k = k * 10 + (c - '0');
            }

            // 2️ 遇到 '['，进入新一层
            else if (c == '[') {
                countStack.push(k);      // 保存当前重复次数
                stringStack.push(curr);  // 保存当前字符串

                curr = "";               // 重置，开始构造子串
                k = 0;                   // 重置 k，准备读下一个数字
            }

            // 3️ 遇到 ']'，解码当前层
            else if (c == ']') {
                string temp = curr;      // 当前层要重复的字符串

                curr = stringStack.top(); // 回到上一层字符串
                stringStack.pop();

                int repeat = countStack.top(); // 当前层重复次数
                countStack.pop();

                // 把 temp 重复 repeat 次拼到 curr 后面
                while (repeat--) {
                    curr += temp;
                }
            }

            // 4️ 普通字符，直接加到当前字符串
            else {
                curr += c;
            }
        }

        // 最终结果
        return curr;
    }
};


```
739每日温度
```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;  // 存储下标
        vector<int> result(temperatures.size(), 0);
        
        st.push(0);  // 初始化第一个元素
        
        for (int i = 1; i < temperatures.size(); i++) {
            if (temperatures[i] < temperatures[st.top()]) {
                // 当前温度小于栈顶，保持单调递减
                st.push(i);
            } else if (temperatures[i] == temperatures[st.top()]) {
                // 当前温度等于栈顶，也入栈
                st.push(i);
            } else {
                // 当前温度大于栈顶，处理栈顶元素
                while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
                    result[st.top()] = i - st.top();  // 计算距离
                    st.pop();
                }
                st.push(i);
            }
        }
        
        return result;
    }
};
```
84柱状图中最大矩形
```cpp

```