35. 搜索插入位置
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        // 分别处理如下四种情况：
        // 1. 目标值在数组所有元素之前  [0, -1]
        // 2. 目标值等于数组中某一个元素  return middle;
        // 3. 目标值插入数组中的位置 [left, right]，return right + 1
        // 4. 目标值在数组所有元素之后的情况 [left, right]，因为是右闭区间，所以return right + 1
        return right + 1;
    }
};
```
74搜索二维矩阵
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false;

        int m = matrix.size();
        int n = matrix[0].size();

        int left = 0;
        int right = m * n - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            int value = matrix[mid / n][mid % n];

            if (value == target) {
                return true;
            } else if (value < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
};

```

34在排序数组中查找元素的第一个和最后一个位置
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        
        // 情况一：target 在数组范围的右边或者左边
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三：target 在数组范围中，且数组中存在target
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二：target 在数组范围中，且数组中不存在target
        return {-1, -1};
    }
    
private:
    // 寻找左边界：target 在 [nums] 的左边
    int getLeftBorder(vector<int>& nums, int target) {
        int leftBorder = -2;  // 记录一下leftBorder没有被赋值的情况
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 在右边，说明左边没有出现过target
                left = mid + 1;
            } else {
                // 在左边，或者相等，重点的找第一次出现的位置
                right = mid - 1;
                leftBorder = right;
            }
        }
        return leftBorder;
    }
    
    // 寻找右边界：[nums] target 在右边
    int getRightBorder(vector<int>& nums, int target) {
        int rightBorder = -2;  // 记录一下rightBorder没有被赋值的情况
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                // 在左边
                right = mid - 1;
            } else {
                // 在右边，或者相等，只关注于最右边的target
                left = mid + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
};
```
33搜索旋转排序数组
```cpp

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if (n == 0) return -1;

        int l = 0, r = n - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] == target) return mid;

            // 左半部分有序
            if (nums[l] <= nums[mid]) {
                if (nums[l] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            // 右半部分有序
            else {
                if (nums[mid] < target && target <= nums[r]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```
153寻找排序数组中的最小值
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        //遍历一次找到第一个下降的点？
        int index=0;
        for(int i=0;i<nums.size()-1;i++){
            if(nums[i+1]<nums[i]) {
                index=i+1;
                break;
            }
        }
        return nums[index];
    }
};

class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] > nums[right]) {
                // 最小值在右半部分
                left = mid + 1;
            } else {
                // 最小值在左半部分（包含 mid）
                right = mid;
            }
        }
        return nums[left];
    }
};

```
4寻找两个正序数组的中位数
```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums;
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        nums.insert(nums.end(), nums2.begin(), nums2.end());

        sort(nums.begin(), nums.end());

        int n = nums.size();
        if (n % 2 == 1) {
            return nums[n / 2];
        } else {
            return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;
        }
    }
};
```
