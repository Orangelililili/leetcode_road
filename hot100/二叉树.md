94二叉树的中序遍历
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        //统一迭代法
        //用nullptr去标记需要处理的节点
        vector<int> result;
        stack<TreeNode*> st;
        if(root!=nullptr) st.push(root);

        while(!st.empty()){
            TreeNode* node=st.top();
            if(node!=nullptr){
                st.pop();

                if(node->right) st.push(node->right);
                st.push(node);
                st.push(nullptr);
                if(node->left) st.push(node->left);
            }else{
                //弹出空节点
                st.pop();
                node=st.top();
                st.pop();
                result.push_back(node->val);
            }
        }

        return result;
    }
};
```

104二叉树的最大深度
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //后序遍历，左右中
        //返回左右子树的最大深度+1
        if(root==nullptr) return 0;

        int leftDepth=maxDepth(root->left);
        int rightDepth=maxDepth(root->right);

        return 1+max(leftDepth,rightDepth);
    }
};
```

226翻转二叉树
```cpp

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return root;

        swap(root->left,root->right);

        invertTree(root->left);
        invertTree(root->right);

        return root;
    }
};
```

101对称二叉树
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return compare(root->left,root->right);
    }

    bool compare(TreeNode* left,TreeNode* right){
        if(left==nullptr && right==nullptr) return true;
        if(left==nullptr||right==nullptr) return false;

        if(left->val!=right->val)return false;
        bool outside=compare(left->left,right->right);
        bool inside=compare(left->right,right->left);

        return outside&&inside;
    }
};
```

543二叉树的直径
```cpp
class Solution {
public:
    int maxd=0;

    int depth(TreeNode* node){
        if(node==nullptr) return 0;

        int left=depth(node->left);
        int right=depth(node->right);
        maxd=max(left+right,maxd);
        return max(left,right)+1;

    }
    int diameterOfBinaryTree(TreeNode* root) {
        depth(root);
        return maxd;
    }
};
```
102二叉树的层序遍历
```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode*> que;
        if(root==nullptr)return result;
        que.push(root);

        while(!que.empty()){
            int size=que.size();
            vector<int> vec;

            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                vec.push_back(node->val);

                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);
        }

        return result;
    }
};
```

108将有序数组转换成二叉搜索树
```cpp
class Solution {

private:
    TreeNode* traversal(vector<int>& nums,int left,int right){
        if(left>right) return nullptr;
        int mid=left+(right-left)/2;
        TreeNode* root=new TreeNode(nums[mid]);

        root->left=traversal(nums,left,mid-1);
        root->right=traversal(nums,mid+1,right);

        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
       
        return  traversal(nums,0,nums.size()-1);
    }
};
```

98验证二叉搜索树
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if(root != nullptr) st.push(root);
        
        while(!st.empty()) {
            TreeNode* node = st.top();
            if(node != nullptr) {
                st.pop();
                if(node->right) st.push(node->right);
                st.push(node);
                st.push(nullptr);
                if(node->left) st.push(node->left);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        
        // 判断是否有序
        for(int i = 1; i < result.size(); i++) {
            if(result[i] <= result[i - 1]) {  // 注意：BST不能有重复元素
                return false;
            }
        }
        return true;
    }
};
```

230二叉搜索树中第k小的元素
```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector<int> result;
        stack<TreeNode*> st;
        if(root!=nullptr) st.push(root);

        while(!st.empty()){
            TreeNode* node=st.top();
            if(node!=nullptr){
                st.pop();
                if(node->right)st.push(node->right);
                st.push(node);
                st.push(nullptr);
                if(node->left)st.push(node->left);
            }else{
                st.pop();
                node=st.top();
                st.pop();
                result.push_back(node->val);
            }
        }

        return result[k-1];
    }
};
```
199二叉树的右视图
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        //二叉树的层序遍历，每一层vec的最后一个元素
        vector<int> result;
        queue<TreeNode*> que;

        if(root!=nullptr) que.push(root);

        while(!que.empty()){
            int size=que.size();
            vector<int> vec;

            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                vec.push_back(node->val);

                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }

            result.push_back(vec.back());
        }

        return result;
    }
};
```

114二叉树展开为链表
```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        // 如果树本身就是空的，什么都不用做
        if (root == nullptr) return;

        // 栈：用来模拟递归，实现前序遍历
        stack<TreeNode*> st;

        // 先把根节点压栈
        st.push(root);

        // prev 表示“前一个访问的节点”
        // 用它来把当前节点接到链表上
        TreeNode* prev = nullptr;

        // 栈不为空，说明还有节点没处理
        while (!st.empty()) {

            // 取出当前要处理的节点
            TreeNode* cur = st.top();
            st.pop();

            // 如果已经有前一个节点了
            // 就把前一个节点的 right 指向当前节点
            // 并把前一个节点的 left 置空（链表要求）
            if (prev != nullptr) {
                prev->right = cur;
                prev->left = nullptr;
            }

            // 注意压栈顺序！！！
            // 因为栈是后进先出（LIFO）
            // 想要“前序遍历：中 → 左 → 右”
            // 就必须“先压右，再压左”

            // 右孩子先压栈
            if (cur->right)
                st.push(cur->right);

            // 左孩子后压栈
            if (cur->left)
                st.push(cur->left);

            // 当前节点处理完之后
            // 更新 prev，供下一个节点连接使用
            prev = cur;
        }
    }
};

```
105从前序与中序遍历序列构造二叉树
```cpp
class Solution {
private:
    TreeNode* traversal(vector<int>& preorder, vector<int>& inorder) {
        // 递归终止
        if (preorder.empty()) return nullptr;

        // 前序遍历第一个元素是根
        int rootValue = preorder[0];
        TreeNode* root = new TreeNode(rootValue);

        // 只有一个节点，直接返回
        if (preorder.size() == 1) return root;

        // 在中序中找到根节点位置
        int delimiterIndex = 0;
        for (; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue)
                break;
        }

        // 切割中序数组
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end());

        // 切割前序数组（跳过第一个根节点）
        vector<int> newPreorder(preorder.begin() + 1, preorder.end());

        vector<int> leftPreorder(
            newPreorder.begin(),
            newPreorder.begin() + leftInorder.size()
        );

        vector<int> rightPreorder(
            newPreorder.begin() + leftInorder.size(),
            newPreorder.end()
        );

        // 递归构造左右子树
        root->left = traversal(leftPreorder, leftInorder);
        root->right = traversal(rightPreorder, rightInorder);

        return root;
    }

public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty()) return nullptr;
        return traversal(preorder, inorder);
    }
};

```
437路径总和｜｜｜
```cpp

class Solution {
private:
    int result = 0;

    // 从当前节点开始，向下寻找路径
    void traversal(TreeNode* root, long long targetSum) {
        if (root == nullptr) return;

        // 如果当前路径和正好等于 targetSum
        if (root->val == targetSum) {
            result++;
        }

        // 继续向左、向右延伸路径
        traversal(root->left, targetSum - root->val);
        traversal(root->right, targetSum - root->val);
    }

public:
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;

        // 以 root 作为路径起点
        traversal(root, targetSum);

        // 以左子树的节点作为路径起点
        pathSum(root->left, targetSum);

        // 以右子树的节点作为路径起点
        pathSum(root->right, targetSum);

        return result;
    }
};

```

236二叉树的最近公共祖先
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p||root==q||root==nullptr){//递归终止条件
            return root;
        }

        TreeNode* left=lowestCommonAncestor(root->left,p,q);
        TreeNode* right=lowestCommonAncestor(root->right,p,q);

        if(left!=nullptr&&right!=nullptr){
            //找到了
            return root;
        }

        if(left!=nullptr) return left;
        if(right!=nullptr) return right;

        return nullptr;
    }
};
```
124二叉树中的最大路径和
```cpp
class Solution {
private:
    int maxSum = INT_MIN;

public:
    int maxGain(TreeNode* node) {
        if (node == nullptr) return 0;

        int leftGain = max(maxGain(node->left), 0);
        int rightGain = max(maxGain(node->right), 0);

        // 尝试以 node 为最高点更新答案
        maxSum = max(maxSum, node->val + leftGain + rightGain);

        // 返回给父节点（只能选一边）
        return node->val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;   //  关键在这里
    }
};

```