46全排列
```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;

    void backtracking(vector<int>& nums,vector<bool>& used){
        if(path.size()==nums.size()){
            result.push_back(path);
            
            return;
        }

        for(int i=0;i<nums.size();i++){
            if(used[i]==true) continue;
            used[i]=true;
            path.push_back(nums[i]);
            backtracking(nums,used);
            path.pop_back();
            used[i]=false;
        }
    }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        //递归往往和回溯搭配
        result.clear();
        path.clear();
        vector<bool> used(nums.size(),false);
        backtracking(nums,used);
        return result;
    }
};
```
78子集
```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> result;
    
    void backTracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size()) {
            return;
        }
        
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        result.clear();
        backTracking(nums, 0);
        return result;
    }
};
```

17电话号码的字母组合
```cpp
class Solution {
private:
    const string letterMap[10]{
        "",//0
        "",//1
        "abc",//2
        "def",//3
        "ghi",//4
        "jkl",//5
        "mno",//6
        "pqrs",//7
        "tuv",//8
        "wxyz",//9
    };

    vector<string>result;
    string s;

    void backtracking(string digits,int startIndex){
        if(startIndex==digits.size()){
            result.push_back(s);
            return;
        }

        int digit=digits[startIndex]-'0';//ascii码连续，把char换成真正的数字
        string letters=letterMap[digit];
        for(int i=0;i<letters.size();i++){
            s.push_back(letters[i]);
            backtracking(digits,startIndex+1);
            s.pop_back();
        }
    }
public:
    vector<string> letterCombinations(string digits) {
        result.clear();
        s.clear();
        if(digits.size()==0){
            return result;
        }

        backtracking(digits,0);
        return result;
    }
};
```

39组合总和
```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;

    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) return;

        if (sum == target) {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);

            // i 传进去，表示可以重复选当前数
            backtracking(candidates, target, sum, i);

            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
};

```

22括号生成
```cpp
class Solution {
private:
    vector<string> result;
    string path;

    void backtracking(int n, int left, int right) {
        // 终止条件
        if (left == n && right == n) {
            result.push_back(path);
            return;
        }

        // 放左括号
        if (left < n) {
            path.push_back('(');
            backtracking(n, left + 1, right);
            path.pop_back();
        }

        // 放右括号
        if (right < left) {
            path.push_back(')');
            backtracking(n, left, right + 1);
            path.pop_back();
        }
    }

public:
    vector<string> generateParenthesis(int n) {
        result.clear();
        path.clear();
        backtracking(n, 0, 0);
        return result;
    }
};

```

79单词搜索
```cpp
class Solution {
private:
    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i,
               int j, string& s, int k) {
        if (board[i][j] != s[k]) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }

        visited[i][j] = true;
        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        bool result = false;
        for (const auto& dir : directions) {
            int newi = i + dir.first, newj = j + dir.second;
            if (newi >= 0 && newi < board.size() && newj >= 0 &&
                newj < board[0].size()) {
                if (!visited[newi][newj]) {
                    bool flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }

public:
    bool exist(vector<vector<char>>& board, string word) {
        int h = board.size(), w = board[0].size();
        vector<vector<int>> visited(h, vector<int>(w));
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                bool flag = check(board, visited, i, j, word, 0);
                if (flag)
                    return true;
            }
        }
        return false;
    }
};
```

131分割回文串
```cpp
class Solution {
private:
    int n;                               // 字符串长度
    vector<vector<string>> ans;          // 最终结果：所有合法分割方案
    vector<string> split_str;            // 当前路径（已经切好的若干子串）

    // 判断 s[left..right] 是否是回文串
    bool is_palindrome(string &s, int left, int right) {
        // 双指针向中间靠拢
        while (left < right) {
            if (s[left] != s[right]) {
                return false;             // 只要有一对不相等，就不是回文
            }
            left++;
            right--;
        }
        return true;
    }

    // 回溯函数
    // index：表示“当前从字符串的哪个位置开始切”
    void backtrace(string &s, int index) {

        // ===== 终止条件 =====
        // index == n，说明字符串已经被完整切完
        if (index == n) {
            ans.push_back(split_str);     // 收集当前这条合法路径
            return;
        }

        // ===== 横向遍历：尝试所有可能的切割终点 =====
        // 从 index 开始，尝试切到 right
        for (int right = index; right < n; right++) {

            // 判断 s[index..right] 是否是回文串
            if (is_palindrome(s, index, right)) {

                // ===== 选择 =====
                // 当前这段是回文，可以加入路径
                split_str.push_back(
                    s.substr(index, right - index + 1)
                );

                // ===== 递归 =====
                // 继续从 right + 1 位置往后切
                backtrace(s, right + 1);

                // ===== 回溯 =====
                // 撤销刚才的选择，尝试下一种切法
                split_str.pop_back();
            }
            // 如果不是回文，直接跳过，相当于剪枝
        }
    }

public:
    vector<vector<string>> partition(string s) {
        n = s.size();          // 记录字符串长度
        ans.clear();           // 清空结果
        split_str.clear();     // 清空路径

        // 从字符串下标 0 开始切
        backtrace(s, 0);

        return ans;
    }
};

```
51N皇后
```cpp
class Solution {
private:
    vector<vector<string>> result;   // 最终结果
    vector<string> board;            // 当前棋盘状态
    int n;

    // 回溯：在第 row 行放皇后
    void backtracking(
        int row,
        vector<bool>& col,           // 列是否被占用
        vector<bool>& diag1,         // 主对角线
        vector<bool>& diag2          // 副对角线
    ) {
        // ===== 终止条件 =====
        // 成功在 0 ~ n-1 行都放好了皇后
        if (row == n) {
            result.push_back(board);
            return;
        }

        // ===== 尝试在第 row 行的每一列放皇后 =====
        for (int c = 0; c < n; c++) {

            // 判断当前位置是否合法
            if (col[c] || diag1[row + c] || diag2[row - c + n - 1]) {
                continue;  // 有冲突，跳过
            }

            // ===== 选择 =====
            board[row][c] = 'Q';
            col[c] = true;
            diag1[row + c] = true;//左下左上
            diag2[row - c + n - 1] = true;//右下右上
            //整体平移n-1，因为最小值是-（n-1）

            // ===== 递归 =====
            backtracking(row + 1, col, diag1, diag2);

            // ===== 回溯 =====
            board[row][c] = '.';
            col[c] = false;
            diag1[row + c] = false;
            diag2[row - c + n - 1] = false;
        }
    }

public:
    vector<vector<string>> solveNQueens(int n) {
        this->n = n;
        result.clear();

        // 初始化棋盘
        board = vector<string>(n, string(n, '.'));

        // 记录列和对角线占用情况
        vector<bool> col(n, false);
        vector<bool> diag1(2 * n - 1, false);  // row + col
        vector<bool> diag2(2 * n - 1, false);  // row - col + n - 1
        //取值从0到2（n-1）

        // 从第 0 行开始回溯
        backtracking(0, col, diag1, diag2);

        return result;
    }
};

```