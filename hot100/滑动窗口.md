3无重复字符的最长子串
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> occ;  // 当前窗口中的字符集合（保证无重复）
        int left = 0, right = 0;  // 左右指针
        int res = 0;              // 最长无重复子串长度

        while (right < s.size()) {

            // ① 当右指针指向的字符不在窗口中 → 可以扩张窗口
            if (!occ.count(s[right])) {
                occ.insert(s[right]);                         // 加入窗口
                res = max(res, right - left + 1);             // 更新最大长度
                right++;                                      // 移动右指针扩大窗口
            }
            else {
                // ② 当出现重复字符 s[right]
                // 把 left 指向的字符从窗口移除，然后把 left ++
                occ.erase(s[left]);
                left++;    // 收缩窗口（直到无重复为止）
            }
        }

        return res;
    }
};

```

438找到字符串中所有字母异位词
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        if (s.size() < p.size()) return result;

        // 1. 用 multiset 存 p 的所有字符
        multiset<char> target(p.begin(), p.end());

        multiset<char> window;  // 当前滑动窗口的字符

        int left = 0;
        int right = 0;
        int k = p.size();

        // 2. 先把前 k 个字符加入窗口
        for (; right < k; right++) {
            window.insert(s[right]);
        }

        // 3. 判断第一个窗口
        if (window == target) {
            result.push_back(left);
        }

        // 4. 移动滑动窗口（右移一格）
        while (right < s.size()) {
            // （1）移除窗口最左边的字符
            window.erase(window.find(s[left]));
            left++;

            // （2）加入新的右边字符
            window.insert(s[right]);
            right++;

            // （3）判断当前窗口是否为 p 的异位词
            if (window == target) {
                result.push_back(left);
            }
        }

        return result;
    }
};

```
