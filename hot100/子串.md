560和为k的子数组
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        // mp[前缀和] = 出现次数
        unordered_map<int, int> mp;
        // 前缀和为 0 的情况有 1 次（用于处理刚好从开头开始的子数组）
        mp[0] = 1;

        int count = 0;  // 答案
        int pre = 0;    // 当前前缀和

        for (auto& x: nums) {
            pre += x;  // 计算到当前位置的前缀和

            // 如果之前有某个前缀和 = pre - k
            // 那么从那个前缀和的下一位到当前位的子数组之和就为 k
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k]; // 累加出现次数
            }

            // 当前前缀和计数 +1
            mp[pre]++;
        }

        return count;
    }
};


```

239滑动窗口最大值

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

        // priority_queue 默认是【最大堆】
        // 存 pair<int,int> 表示 {值, 下标}
        // 会自动按照 pair 的比较规则进行排序
        // （先比 value 值大小，再比 index）
        priority_queue<pair<int,int>> pq;

        int n = nums.size();

        // 先把前 k 个元素加入堆
        for (int i = 0; i < k; ++i) {
            pq.emplace(nums[i], i); 
            // emplace = 构造并放入，效率比 push 高
        }

        // 结果数组，把第一个窗口最大值加入
        vector<int> ans;
        ans.push_back(pq.top().first);
        // pq.top().first 是最大值
        // pq.top().second 是最大值所在下标

        // 开始滑动窗口
        for (int i = k; i < n; ++i) {

            // 1. 把新元素加入堆
            pq.emplace(nums[i], i);

            // 2. 清理窗口左边已经被“滑过去”的元素
            // pq.top().second <= i - k 表示该元素过期
            //窗口是 [i-k+1, i]
            while (pq.top().second <= i - k) {
                pq.pop();  
            }

            // 3. 堆顶就是当前窗口的最大值
            ans.push_back(pq.top().first);
        }

        return ans;
    }
};


```

76最小覆盖子串
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        if (t.size() > s.size()) return "";

        // 1. 统计 t 中每个字符出现的次数
        unordered_map<char, int> need;
        for (char c : t) need[c]++;

        // 2. 滑动窗口计数
        unordered_map<char, int> window;

        int left = 0, right = 0;
        int valid = 0;  // 记录“窗口中满足 need 的字符种类数”
        int minLen = INT_MAX;
        int start = 0;  // 最小覆盖子串的起始位置

        // 3. 开始滑动窗口
        while (right < s.size()) {
            char c = s[right];
            right++;  // 扩大窗口

            /// -------------------------
            /// 处理进入窗口的字符
            /// -------------------------
            if (need.count(c)) {            // 如果是 t 中需要的字符
                window[c]++;                // 加入窗口计数
                if (window[c] == need[c])   // 刚好满足该字符的需求
                    valid++;
            }

            /// -------------------------
            /// 当所有字符都满足需求时，尝试收缩窗口
            /// -------------------------
            while (valid == need.size()) {
                // 更新最小子串
                if (right - left < minLen) {
                    //不是right - left +1< minLen
                    //因为一开始right++了，其实是左闭右开
                    minLen = right - left;
                    start = left;
                }

                // 准备收缩窗口
                char d = s[left];
                left++;

                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;        // 窗口不再满足需求
                    window[d]--;
                }
            }
        }

        return (minLen == INT_MAX) ? "" : s.substr(start, minLen);
    }
};


```