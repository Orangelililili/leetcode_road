160简单链表
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //1.找到链表各自长度
        ListNode* curA=headA;
        ListNode* curB=headB;

        int lengthA=0,lengthB=0;

        while(curA->next!=nullptr){
            lengthA++;
            curA=curA->next;
        }
        while(curB->next!=nullptr){
            lengthB++;
            curB=curB->next;
        }

        curA=headA;
        curB=headB;

        //保持A链最长
        if(lengthB>lengthA){
            swap(lengthA,lengthB);
            swap(curA,curB);
        }
        //长链先走gap步
        int gap=lengthA-lengthB;
        while(gap){
            curA=curA->next;
            gap--;
        }

        while(curA!=nullptr){
            if(curA==curB){
                return curA;
            }
            curA=curA->next;
            curB=curB->next;
        }

        return nullptr;

    }
};
```

206反转链表
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp;//保存cur指向的下一个节点
        ListNode* cur=head;
        ListNode* pre=nullptr;

        while(cur!=nullptr){
            temp=cur->next;
            cur->next=pre;
            //更新
            pre=cur;
            cur=temp;
        }
        return pre;//pre指向新的头节点
    }
};
```

234回文链表
```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true;

        // 1. 快慢指针找中点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 2. 反转后半段
        ListNode* prev = nullptr;
        ListNode* cur = slow;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }

        // 3. 比较前后两段
        ListNode* left = head;
        ListNode* right = prev;
        while (right) {
            if (left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }

        return true;
    }
};


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
       //把链表值复制到数组，然后双指针对比
       vector<int> vals;
        while(head!=nullptr){
            vals.emplace_back(head->val);
            head=head->next;
        }

        for(int i=0,j=vals.size()-1;i<j;i++,j--){
            if(vals[i]!=vals[j]) return false;
        }
        return true;
    }
};
```

141环形链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        //快慢指针，要是相遇就是有环
        ListNode* slow=head;
        ListNode* fast=slow;

        while(fast!=nullptr&&fast->next!=nullptr){
            
            fast=fast->next->next;
            slow=slow->next;

            if(fast==slow) return true;
        }
        return false;
    }
};
```
```
解释：
一、图
head
  |
  |---- a ----> 入口 E
                   |
                   |---- b ----> 相遇点 M
                   |              |
                   |              |
                   <---- c - b ----
定义变量（统一）：
符号	含义
a	head → 环入口 E
b	环入口 E → 相遇点 M
c	环的总长度

二、快慢指针「第一次相遇」时，各自走了多少步？
1️. 慢指针 slow
slow 每次走 1 步
第一次相遇时，它一定已经：
走过 a（进环）
再在环里走了 b
所以：
slow 总步数 = a + b

2️. 快指针 fast
fast 每次走 2 步
同一时间内，fast 走的步数是 slow 的 2 倍：
fast 总步数 = 2(a + b)

三、关键点：fast 比 slow 多走的路去了哪里？
这一步是 整个证明的核心。
fast 和 slow 在同一个点相遇，说明：
fast 比 slow 多走的那部分，一定是在「环里绕圈」
fast 比 slow 多走了多少？
fast - slow
= 2(a + b) - (a + b)
= a + b

fast 比 slow 多走了 a + b 步
而在环里，多走一整圈是 c
所以：
a + b = k * c   （k ≥ 1，整数）

四、从关键等式推导入口关系
我们现在有：
a + b = k * c
两边同时减去 b：
a = k * c - b
把右边拆开：
a = (k - 1) * c + (c - b)

五、这行公式意味着
再看一眼：
a = (k - 1) * c + (c - b)
解释成“走路”：
(k - 1) * c：在环里多绕几圈（不影响位置）
c - b：从相遇点 M 走到入口 E 的距离
所以这句话的真正含义是：
从相遇点 M 出发，走 a 步，一定会回到入口 E

六、为什么「一个从 head，一个从相遇点，同速走」？
现在再看这一步：
指针 1：从 head 出发
head → 入口 E 的距离 = a
指针 2：从相遇点 M 出发
M → 入口 E 的距离 = c - b
再多绕 (k - 1) 圈无所谓
两者走同样的 a 步，一定在入口 E 相遇

所以index1=fast之后还是要走
```

21合并两个有序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //虚拟头节点
        ListNode dummy(0);
        ListNode* cur =&dummy;

        while(list1&&list2){
            if(list1->val<list2->val){
                cur->next=list1;
                list1=list1->next;
            }else{
                cur->next=list2;
                list2=list2->next;
            }
            cur=cur->next;
        }

        cur->next=list1? list1:list2    ;

        return dummy.next;
    }
};
```

2. 两数相加
```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int sum = carry;

            if (l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                sum += l2->val;
                l2 = l2->next;
            }

            carry = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
        }

        return dummy.next;
    }
};

```

19删除链表倒数第n个节点
```cpp


```