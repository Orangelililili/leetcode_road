160简单链表
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //1.找到链表各自长度
        ListNode* curA=headA;
        ListNode* curB=headB;

        int lengthA=0,lengthB=0;

        while(curA->next!=nullptr){
            lengthA++;
            curA=curA->next;
        }
        while(curB->next!=nullptr){
            lengthB++;
            curB=curB->next;
        }

        curA=headA;
        curB=headB;

        //保持A链最长
        if(lengthB>lengthA){
            swap(lengthA,lengthB);
            swap(curA,curB);
        }
        //长链先走gap步
        int gap=lengthA-lengthB;
        while(gap){
            curA=curA->next;
            gap--;
        }

        while(curA!=nullptr){
            if(curA==curB){
                return curA;
            }
            curA=curA->next;
            curB=curB->next;
        }

        return nullptr;

    }
};
```

206反转链表
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp;//保存cur指向的下一个节点
        ListNode* cur=head;
        ListNode* pre=nullptr;

        while(cur!=nullptr){
            temp=cur->next;
            cur->next=pre;
            //更新
            pre=cur;
            cur=temp;
        }
        return pre;//pre指向新的头节点
    }
};
```

234回文链表
```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true;

        // 1. 快慢指针找中点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // 2. 反转后半段
        ListNode* prev = nullptr;
        ListNode* cur = slow;
        while (cur) {
            ListNode* next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
        }

        // 3. 比较前后两段
        ListNode* left = head;
        ListNode* right = prev;
        while (right) {
            if (left->val != right->val) return false;
            left = left->next;
            right = right->next;
        }

        return true;
    }
};


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
       //把链表值复制到数组，然后双指针对比
       vector<int> vals;
        while(head!=nullptr){
            vals.emplace_back(head->val);
            head=head->next;
        }

        for(int i=0,j=vals.size()-1;i<j;i++,j--){
            if(vals[i]!=vals[j]) return false;
        }
        return true;
    }
};
```

141环形链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        //快慢指针，要是相遇就是有环
        ListNode* slow=head;
        ListNode* fast=slow;

        while(fast!=nullptr&&fast->next!=nullptr){
            
            fast=fast->next->next;
            slow=slow->next;

            if(fast==slow) return true;
        }
        return false;
    }
};
```
```
解释：
一、图
head
  |
  |---- a ----> 入口 E
                   |
                   |---- b ----> 相遇点 M
                   |              |
                   |              |
                   <---- c - b ----
定义变量（统一）：
符号	含义
a	head → 环入口 E
b	环入口 E → 相遇点 M
c	环的总长度

二、快慢指针「第一次相遇」时，各自走了多少步？
1️. 慢指针 slow
slow 每次走 1 步
第一次相遇时，它一定已经：
走过 a（进环）
再在环里走了 b
所以：
slow 总步数 = a + b

2️. 快指针 fast
fast 每次走 2 步
同一时间内，fast 走的步数是 slow 的 2 倍：
fast 总步数 = 2(a + b)

三、关键点：fast 比 slow 多走的路去了哪里？
这一步是 整个证明的核心。
fast 和 slow 在同一个点相遇，说明：
fast 比 slow 多走的那部分，一定是在「环里绕圈」
fast 比 slow 多走了多少？
fast - slow
= 2(a + b) - (a + b)
= a + b

fast 比 slow 多走了 a + b 步
而在环里，多走一整圈是 c
所以：
a + b = k * c   （k ≥ 1，整数）

四、从关键等式推导入口关系
我们现在有：
a + b = k * c
两边同时减去 b：
a = k * c - b
把右边拆开：
a = (k - 1) * c + (c - b)

五、这行公式意味着
再看一眼：
a = (k - 1) * c + (c - b)
解释成“走路”：
(k - 1) * c：在环里多绕几圈（不影响位置）
c - b：从相遇点 M 走到入口 E 的距离
所以这句话的真正含义是：
从相遇点 M 出发，走 a 步，一定会回到入口 E

六、为什么「一个从 head，一个从相遇点，同速走」？
现在再看这一步：
指针 1：从 head 出发
head → 入口 E 的距离 = a
指针 2：从相遇点 M 出发
M → 入口 E 的距离 = c - b
再多绕 (k - 1) 圈无所谓
两者走同样的 a 步，一定在入口 E 相遇

所以index1=fast之后还是要走
```

21合并两个有序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //虚拟头节点
        ListNode dummy(0);
        ListNode* cur =&dummy;

        while(list1&&list2){
            if(list1->val<list2->val){
                cur->next=list1;
                list1=list1->next;
            }else{
                cur->next=list2;
                list2=list2->next;
            }
            cur=cur->next;
        }

        cur->next=list1? list1:list2    ;

        return dummy.next;
    }
};
```

2. 两数相加
```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);
        ListNode* cur = &dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int sum = carry;

            if (l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                sum += l2->val;
                l2 = l2->next;
            }

            carry = sum / 10;
            cur->next = new ListNode(sum % 10);
            cur = cur->next;
        }

        return dummy.next;
    }
};

```

19删除链表倒数第n个节点
```cpp

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //快慢指针
        //快指针先走n+1步
        //然后快慢指针一块走，slow正好就在要删除的节点
        ListNode* dummy=new ListNode(0);
        dummy->next=head;
        ListNode* fast =dummy;
        ListNode* slow=dummy;

        while(n--&&fast!=nullptr){
            fast=fast->next;
        }
        fast=fast->next;//到最后一个节点的next，即nullptr

        while(fast!=nullptr){
            fast=fast->next;
            slow=slow->next;
        }

        //删除
        slow->next=slow->next->next;

        return dummy->next;
    }
};
```

24两两交换链表中的节点
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dunmmy(0);
        dunmmy.next=head;
        ListNode* prev=&dunmmy;

        while(prev->next!=nullptr&&prev->next->next!=nullptr){
            ListNode* first=prev->next;
            ListNode* second=prev->next->next;

            //交换
            first->next=second->next;
            second->next=first;
            prev->next=second;

            //前进
            prev=first;
        }

        return dunmmy.next;
    }
};

```

25K个一组翻转链表
```cpp
pair<ListNode*, ListNode*> reverse(ListNode* head, ListNode* tail) {
    ListNode* prev = tail->next; //  关键
    ListNode* cur = head;

    while (prev != tail) {
        ListNode* temp = cur->next;
        cur->next = prev;
        prev = cur;
        cur = temp;
    }
    return {tail, head}; // 新头、新尾
}
/*
假设当前这一组是：
head = 1
tail = 3
tail->next = 4
初始状态
prev = 4
cur  = 1

第一次循环
temp = 2
1->next = 4
prev = 1
cur = 2
链表局部变成：
1 -> 4
2 -> 3 -> 4

第二次循环
temp = 3
2->next = 1
prev = 2
cur = 3
2 -> 1 -> 4
3 -> 4

第三次循环
temp = 4
3->next = 2
prev = 3
cur = 4
3 -> 2 -> 1 -> 4

循环结束条件
while (prev != tail)
当 prev == 3 (tail)，停止。
*/
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode dummy(0);
        dummy.next = head;
        ListNode* prev = &dummy;

        while (true) {
            // 1️⃣ 找到这一组的尾巴
            ListNode* tail = prev;
            for (int i = 0; i < k; i++) {
                tail = tail->next;
                if (!tail)
                    return dummy.next;
            }

            // 2️⃣ 记住下一组的头
            ListNode* nextGroupHead = tail->next;

            // 3️⃣ 反转这一组
            auto [newHead, newTail] = reverse(prev->next, tail);

            // 4️⃣ 接回原链表
            prev->next = newHead;
            newTail->next = nextGroupHead;

            // 5️⃣ prev 前进，准备下一组
            prev = newTail;
        }
    }
};

//还是用栈更好
ListNode* reverseKGroup(ListNode* head, int k) {
    stack<ListNode*> st;
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prev = &dummy;
    ListNode* cur = head;

    while (cur) {
        // 1️⃣ 入栈 k 个
        for (int i = 0; i < k; i++) {
            if (!cur) return dummy.next;
            st.push(cur);
            cur = cur->next;
        }

        // 2️⃣ 出栈并接回
        while (!st.empty()) {
            prev->next = st.top();
            st.pop();
            prev = prev->next;
        }

        // 3️⃣ 接回后续
        prev->next = cur;
    }
    return dummy.next;
}

```

138随机链表的复制
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};

```

148排序链表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    // 递归归并
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }

        ListNode *slow = head, *fast = head, *prev = nullptr;
        while (fast && fast->next) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }

        prev->next = nullptr; // 切成两段
        ListNode* l1 = sortList(head);
        ListNode* l2 = sortList(slow);

        return merage(l1, l2);
    }

private:
    ListNode* merage(ListNode* l1, ListNode* l2) {
        ListNode dummy(0);

        ListNode* cur = &dummy;

        while (l1 && l2) {
            if (l1->val > l2->val) {
                cur->next = l2;
                l2 = l2->next;
            } else {
                cur->next = l1;
                l1 = l1->next;
            }

            cur = cur->next;
        }
        cur->next = l1 ? l1 : l2;

        return dummy.next;
    }
};
```

23合并K个升序列表
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
    if(lists.empty()) return nullptr;
    int interval = 1;
    while(interval < lists.size()) {
        for(int i = 0; i + interval < lists.size(); i += interval*2) {
            lists[i] = mergeTwoList(lists[i], lists[i+interval]);
        }
        interval *= 2;
    }
    return lists[0];
}

private:
    ListNode* mergeTwoList(ListNode* l1,ListNode* l2){
        ListNode dummy(0);
        ListNode* cur=& dummy;
        while(l1&& l2){
            if(l1->val>l2->val){
                cur->next=l2;
                l2=l2->next;
            }else{
                cur->next=l1;
                l1=l1->next;
            }
            cur=cur->next;
        }

        cur->next=l1? l1:l2;
        return dummy.next;
    }
};
```

146LRU缓存
```cpp
struct Node {
    int key, value;
    Node* prev;
    Node* next;
    Node(int k, int v): key(k), value(v), prev(nullptr), next(nullptr) {}
};


class LRUCache {
private:
    int capacity;
    unordered_map<int, Node*> cache;
    Node* head; // 最近使用
    Node* tail; // 最久未使用

    // 移动节点到头
    void moveToHead(Node* node) {
        if(node == head) return;
        
        // 先断开
        if(node->prev) node->prev->next = node->next;
        if(node->next) node->next->prev = node->prev;
        if(node == tail) tail = node->prev;

        // 插入到头
        node->next = head;
        node->prev = nullptr;
        if(head) head->prev = node;
        head = node;
        if(!tail) tail = head;
    }

    // 删除尾部节点
    void removeTail() {
        if(!tail) return;
        cache.erase(tail->key);
        Node* prev = tail->prev;
        delete tail;
        tail = prev;
        if(tail) tail->next = nullptr;
        else head = nullptr;
    }

public:
    LRUCache(int cap) {
        capacity = cap;
        head = nullptr;
        tail = nullptr;
    }

    int get(int key) {
        if(cache.find(key) == cache.end()) return -1;
        Node* node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value) {
        if(cache.find(key) != cache.end()) {
            Node* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            Node* node = new Node(key, value);
            cache[key] = node;
            moveToHead(node);
            if(cache.size() > capacity) removeTail();
        }
    }
};

```