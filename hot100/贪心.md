121买卖股票的最佳时机
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0; // 空数组特判

        int minPrice = prices[0];   // 当前最小买入价
        int maxProfit = 0;          // 最大利润初始化为0

        for (int i = 1; i < prices.size(); i++) {
            // 1. 当前卖出价格 - 最小买入价 = 当前利润
            int profit = prices[i] - minPrice;

            // 2. 更新最大利润
            if (profit > maxProfit) {
                maxProfit = profit;
            }

            // 3. 更新最小买入价
            if (prices[i] < minPrice) {
                minPrice = prices[i];
            }
        }

        return maxProfit;
    }
};

```
55跳跃游戏
```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover=0;

        for(int i=0;i<=cover;i++){
            cover=max(cover,i+nums[i]);

            if(cover>=nums.size()-1) return true;
        }

        return false;
    }
};
```

45跳跃游戏｜｜
```cpp
//正向
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size()==1) return 0;

        int curDistance=0;
        int ans=0;
        int nextDistance=0;

        for(int i=0;i<nums.size();i++){
            nextDistance=max(nextDistance,i+nums[i]);

            if(i==curDistance){
                ans++;
                curDistance=nextDistance;

                if(curDistance>=nums.size()-1){
                    break;
                }
            }
        }

        return ans;
    }
};
//反向
class Solution {
public:
    int jump(vector<int>& nums) {
        int position = nums.size() - 1;
        int steps = 0;
        while (position > 0) {
            for (int i = 0; i < position; i++) {
                if (i + nums[i] >= position) {
                    position = i;
                    steps++;
                    break;
                }
            }
        }
        return steps;
    }
};


```
763划分字母区间
```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        // 1. 记录每个字符最后出现的位置
        vector<int> last(26, 0);
        for (int i = 0; i < s.size(); i++) {
            last[s[i] - 'a'] = i;
        }

        vector<int> result;
        int start = 0; // 当前段起点
        int end = 0;   // 当前段终点

        // 2. 贪心遍历
        for (int i = 0; i < s.size(); i++) {
            // 更新当前段的最远右边界
            end = max(end, last[s[i] - 'a']);

            // 3. 到达边界，可以切分
            if (i == end) {
                result.push_back(end - start + 1);
                start = i + 1; // 开启新一段
            }
        }

        return result;
    }
};

```