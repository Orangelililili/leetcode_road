

73矩阵置0
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        //遍历到ij后置0，并标记，要是之后有重复可以忽略
        int m=matrix.size();
        int n=matrix[0].size();
        vector<int> row(m),col(n);

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(!matrix[i][j]){
                    row[i]=col[j]=true;
                }
            }
        }

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(row[i]||col[j]){
                    matrix[i][j]=0;
                }
            }
        }
    }
};

```

54螺旋矩阵
```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        int m = matrix.size();
        int n = matrix[0].size();

        int startx = 0, starty = 0;
        int loop = min(m, n) / 2;
        int offset = 1;

        while (loop--) {
            int i = startx, j = starty;

            // 从左到右
            for (; j < n - offset; j++)
                result.push_back(matrix[i][j]);

            // 从上到下
            for (; i < m - offset; i++)
                result.push_back(matrix[i][j]);

            // 从右到左
            for (; j > starty; j--)
                result.push_back(matrix[i][j]);

            // 从下到上
            for (; i > startx; i--)
                result.push_back(matrix[i][j]);

            startx++;
            starty++;
            offset++;
        }

        // 处理剩余的一行或一列
        if (min(m, n) % 2 == 1) {
            if (m <= n) {
                // 剩一行
                for (int j = starty; j <= n - offset; j++)
                    result.push_back(matrix[startx][j]);
            } else {
                // 剩一列
                for (int i = startx; i <= m - offset; i++)
                    result.push_back(matrix[i][starty]);
            }
        }

        return result;
    }
};

```

48旋转图像
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        //如果n是奇数，最中间就不用动
        //矩阵中第i行单第j个元素，转置之后会出现在倒数第i列第j个位置
        //matrix[row][col]=matrix_new[col][n-row-1];
        //两步：先上下翻转，再主对角线翻转
        int n=matrix.size();
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }

        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
};
```

240搜索二维矩阵｜｜

```cpp
class Solution{
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();

    int i = 0, j = n - 1; // 右上角

    while (i < m && j >= 0) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] > target) j--; // 排除一整列
        else i++;                             // 排除一整行
    }
    return false;
    }
};


```