200岛屿数量
```cpp
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int nr = grid.size();
        int nc = grid[0].size();

        grid[r][c] = '0';

        if (r - 1 >= 0 && grid[r - 1][c] == '1')
            dfs(grid, r - 1, c);
        if (r + 1 < nr && grid[r + 1][c] == '1')
            dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c - 1] == '1')
            dfs(grid, r, c - 1);
        if (c + 1 < nc && grid[r][c + 1] == '1')
            dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        // 深搜，在找到一个1之后，就把与之相连的全部置0->淹没
        int nr = grid.size();
        if (!nr)
            return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; r++) {
            for (int c = 0; c < nc; c++) {
                if(grid[r][c]=='1'){
                    num_islands++;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};

//广搜
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        //广搜
        int nr=grid.size();
        if(!nr) return 0;
        int nc=grid[0].size();

        int num_islands=0;
        for(int r=0;r<nr;r++){
            for(int c=0;c<nc;c++){
                if(grid[r][c]=='1'){
                    num_islands++;
                    grid[r][c]='0';

                    queue<pair<int,int>> neighbors;
                    neighbors.push({r,c});

                    while(!neighbors.empty()){
                        auto rc=neighbors.front();
                        neighbors.pop();

                        int row=rc.first,col=rc.second;
                        if(row-1>=0&&grid[row-1][col]=='1') {
                            neighbors.push({row-1,col});
                            grid[row-1][col]='0';
                        }
                        if(row+1<nr &&grid[row+1][col]=='1'){
                            neighbors.push({row+1,col});
                            grid[row+1][col]='0';
                        }
                        if(col-1>=0&&grid[row][col-1]=='1'){
                            neighbors.push({row,col-1});
                            grid[row][col-1]='0';
                        }
                        if(col+1<nc&&grid[row][col+1]=='1'){
                            neighbors.push({row,col+1});
                            grid[row][col+1]='0';
                        }
                    }
                }
            }
        }

        return num_islands;
    }
};
```
994腐烂的橘子
```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int nr = grid.size();
        int nc = grid[0].size();

        queue<pair<int,int>> que;
        int fresh = 0;

        // 1️ 初始化：所有烂橘子入队，统计新鲜橘子
        for (int r = 0; r < nr; r++) {
            for (int c = 0; c < nc; c++) {
                if (grid[r][c] == 2)
                    que.push({r, c});
                else if (grid[r][c] == 1)
                    fresh++;
            }
        }

        int minutes = 0;
        vector<int> dir = {0, 1, 0, -1, 0};

        // 2️ 多源 BFS（按层）
        while (!que.empty() && fresh > 0) {//注意判断条件
            int size = que.size();  // 当前这一分钟要处理的橘子
            minutes++;

            for (int i = 0; i < size; i++) {
                auto [r, c] = que.front();
                que.pop();

                for (int d = 0; d < 4; d++) {
                    int nr2 = r + dir[d];
                    int nc2 = c + dir[d + 1];

                    if (nr2 >= 0 && nr2 < nr && nc2 >= 0 && nc2 < nc
                        && grid[nr2][nc2] == 1) {
                        grid[nr2][nc2] = 2;
                        fresh--;
                        que.push({nr2, nc2});
                    }
                }
            }
        }

        // 3️ 是否还有新鲜橘子
        return fresh == 0 ? minutes : -1;
    }
};

```
207课程表
```cpp
//广搜，khan算法
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 构建邻接表 + 入度数组
        vector<vector<int>> adj(numCourses);
        vector<int> indegree(numCourses, 0);

        // 遍历所有依赖关系
        for (auto &edge : prerequisites) {
            int nxt = edge[0];
            int prev = edge[1];
            adj[prev].push_back(nxt);
            indegree[nxt]++;
        }

        queue<int> q;

        // 所有入度为 0 的课程先入队
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        int count = 0;

        while (!q.empty()) {
            int u = q.front();
            q.pop();
            count++;

            // 当前节点u处理完之后，
            // 所有它指向的节点入度减 1
            for (int v : adj[u]) {
                indegree[v]--;
                if (indegree[v] == 0) {
                    q.push(v);
                }
            }
        }

        // 若能处理的节点等于总节点数，则无环
        return count == numCourses;
    }
};

//深搜
class Solution {
public:
    bool dfs(int u, vector<vector<int>>& adj, vector<int>& state) {
        // 标记为“正在访问”
        state[u] = 1;

        // 遍历所有邻居
        for (int v : adj[u]) {
            if (state[v] == 0) {
                // 如果邻居未访问，则递归访问
                if (!dfs(v, adj, state))
                    return false;
            } else if (state[v] == 1) {
                // 遇到了正在访问的节点 → 环
                return false;
            }
        }

        // 标记为访问完成
        state[u] = 2;
        return true;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 1. 构建邻接表
        vector<vector<int>> adj(numCourses);
        for (auto &edge : prerequisites) {
            int nxt = edge[0];
            int prev = edge[1];
            adj[prev].push_back(nxt);
        }

        // 状态数组：0=未访问；1=访问中；2=访问完毕
        vector<int> state(numCourses, 0);

        // 对每个节点做 DFS
        for (int i = 0; i < numCourses; i++) {
            if (state[i] == 0) {
                if (!dfs(i, adj, state)) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

208实现Trie（前缀树）
```cpp
//trie把公共元素共享，避免重复比较
//字符集固定a到z
class Trie {
private:
    struct TrieNode {
        bool isEnd;
        TrieNode* children[26];

        TrieNode() : isEnd(false) {
            for (int i = 0; i < 26; i++)
                children[i] = nullptr;
        }
    };

    TrieNode* root;

public:
    // 构造函数
    Trie() {
        root = new TrieNode();
    }

    // 插入单词
    void insert(string word) {
        TrieNode* node = root;

        for (char c : word) {
            int idx = c - 'a';
            if (node->children[idx] == nullptr) {
                node->children[idx] = new TrieNode();
            }
            node = node->children[idx];
        }

        // 标记单词结尾
        node->isEnd = true;
    }

    // 查找完整单词
    bool search(string word) {
        TrieNode* node = root;

        for (char c : word) {
            int idx = c - 'a';
            if (node->children[idx] == nullptr)
                return false;
            node = node->children[idx];
        }

        return node->isEnd;
    }

    // 判断是否存在前缀
    bool startsWith(string prefix) {
        TrieNode* node = root;

        for (char c : prefix) {
            int idx = c - 'a';
            if (node->children[idx] == nullptr)
                return false;
            node = node->children[idx];
        }

        return true;
    }
};

```