53最大子数组和
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        // pre 表示：以当前元素结尾的“最大子数组和”
        int pre = 0;

        // maxAns 记录全局最大子数组和，一开始至少是第一个数
        int maxAns = nums[0];

        for (const auto &x : nums) {

            // 要么把 x 接在前面的子数组后面，要么从 x 重新开始
            pre = max(pre + x, x);

            // 更新全局最大值
            maxAns = max(maxAns, pre);
        }

        return maxAns;
    }
};


```


56合并区间
```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;

        // 1. 先按左端点排序（sort 默认按第一列升序）
        sort(intervals.begin(), intervals.end());

        // 2. 遍历每个区间
        for (auto &interval : intervals) {

            // 如果 result 为空，或者当前区间的左端点大于 result 最后区间的右端点
            // → 说明没有重叠，直接加入
            if (result.empty() || interval[0] > result.back()[1]) {
                result.push_back(interval);
            } else {
                // 有重叠 → 需要更新右端点
                // 取更大的右端点（实现合并）
                result.back()[1] = max(result.back()[1], interval[1]);
            }
        }

        return result;
    }
};

```

189轮转数组
```cpp

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n; // 防止 k > n
        
        // 第一步：整体反转
        reverse(nums.begin(), nums.end());
        
        // 第二步：反转前 k 个
        reverse(nums.begin(), nums.begin() + k);
        
        // 第三步：反转后面 n-k 个
        reverse(nums.begin() + k, nums.end());
    }
};

```

238除自身以外数组的乘积
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();

        // L[i] = i 左边所有数的乘积
        // R[i] = i 右边所有数的乘积
        vector<int> L(n, 1), R(n, 1);
        vector<int> ans(n, 0);

        // ======== 构建左侧乘积 L ========
        // i=0 左边没有数，所以乘积 = 1（乘法单位元）
        // 从左往右算：
        // L[i] = L[i-1] * nums[i-1]
        for (int i = 1; i < n; ++i) {
            L[i] = L[i - 1] * nums[i - 1];
            // L[i] 表示 nums[0..i-1] 的全部乘积
        }

        // ======== 构建右侧乘积 R ========
        // 最右边没有数，乘积 = 1
        // 从右往左算：
        // R[i] = R[i+1] * nums[i+1]
        for (int i = n - 2; i >= 0; --i) {
            R[i] = R[i + 1] * nums[i + 1];
            // R[i] 表示 nums[i+1..n-1] 的全部乘积
        }

        // ======== 结合左右两侧乘积（最终答案） ========
        // 因为「除了自己以外」就是：
        // 左边所有乘积 × 右边所有乘积
        for (int i = 0; i < n; ++i) {
            ans[i] = L[i] * R[i];
        }

        return ans;
    }
};

```

41缺失的第一个正数
```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int smallest = 1;  // 期待的最小正整数

        for (int x : nums) {
            if (x == smallest) {
                smallest++;  // 找到这个数了，期待下一个
            }
        }

        return smallest;
    }
};

```