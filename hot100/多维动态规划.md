62不同路径
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));

        // 初始化第一行和第一列
        //只能从左边或者上边过来
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;

        // 状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];//只能从左上过来
            }
        }

        return dp[m - 1][n - 1];
    }
};

```

64最小路径和
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>>dp(m,vector<int>(n,0));
        dp[0][0]=grid[0][0];

        for(int i=1;i<m;i++)dp[i][0]=grid[i][0]+dp[i-1][0];
        for(int j=1;j<n;j++)dp[0][j]=grid[0][j]+dp[0][j-1];

        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }

        return dp[m-1][n-1];
    }
};
```

5.最长回文子串
```cpp
//dp[i][j] 表示：子串 s[i..j] 是否是回文串
//dp[i][i] = true;  // 单个字符一定是回文
//dp[i][j] = (s[i] == s[j]) &&
//           (j - i < 2 || dp[i + 1][j - 1]);//首尾字符相等，中间也是回文
//注意遍历顺序：dp[i][j] 依赖 dp[i+1][j-1]，所以i从大到小，j从小到大


class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n <= 1) return s;

        vector<vector<bool>> dp(n, vector<bool>(n, false));

        int start = 0;   // 最长回文起点
        int maxLen = 1; // 最长回文长度

        // i 从后往前，保证 dp[i+1][j-1] 已计算
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1])) {
                    dp[i][j] = true;

                    if (j - i + 1 > maxLen) {
                        maxLen = j - i + 1;
                        start = i;
                    }
                }
            }
        }

        return s.substr(start, maxLen);
    }
};

```
1143最长公共子序列
```cpp
//dp[i][j] 表示：text1 的前 i 个字符和text2 的前 j 个字符的最长公共子序列长度
//dp[0][j] = 0，dp[i][0] = 0，只要有一个字符串长度为 0，公共子序列长度一定是 0

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();

        // dp[i][j]：text1 前 i 个字符 和 text2 前 j 个字符 的 LCS 长度
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 遍历两个字符串
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                // 当前字符相等
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                // 当前字符不相等
                else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }
};


```
72编辑距离
```cpp
//dp[i][j] = word1 的前 i 个字符变成word2 的前 j 个字符所需的最少操作数
//初始化：
// dp[0][j] = j//word1位为空只能插入。
// dp[i][0] = i//word2为空只能删除
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();

        // dp[i][j]：word1前i个字符变成word2前j个字符的最少操作数
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 初始化：空串情况
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;   // 删除
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;   // 插入
        }

        // 填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                if (word1[i - 1] == word2[j - 1]) {
                    // 字符相等，不需要操作
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 三种操作取最小
                    dp[i][j] = min({
                        dp[i - 1][j],     // 删除
                        dp[i][j - 1],     // 插入
                        dp[i - 1][j - 1]  // 替换
                    }) + 1;
                }
            }
        }

        return dp[m][n];
    }
};

```