215数组中的第k个最大元素
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        // priority_queue 默认是大根堆
        // 这里通过 greater<int> 改成「小根堆」
        // 堆顶永远是当前堆中最小的元素
        priority_queue<int, vector<int>, greater<int>> minHeap;

        // 遍历数组中的每一个元素
        for (int x : nums) {

            // 1. 先把当前元素放进堆中
            minHeap.push(x);

            // 2. 如果堆的大小超过 k
            //    说明当前堆里有 k+1 个元素
            //    需要把最小的那个弹掉
            if (minHeap.size() > k) {
                minHeap.pop();
            }
        }

        // 走到这里：
        // 堆中恰好剩下 k 个元素
        // 这 k 个元素是整个数组中最大的 k 个
        // 堆顶是这 k 个里最小的一个
        // 也就是「第 k 大」
        return minHeap.top();
    }
};

```

347前k个高频元素
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {

        // 1. 统计每个数字出现的次数
        unordered_map<int, int> freq;
        for (int x : nums) {
            freq[x]++;
        }

        // 2. 小根堆：
        // pair.first  = 出现频率
        // pair.second = 数值本身
        priority_queue<
            pair<int, int>,
            vector<pair<int, int>>,
            greater<pair<int, int>>
        > minHeap;

        // 3. 遍历频率表
        for (auto& it : freq) {
            int num = it.first;
            int count = it.second;

            // 把当前元素放入堆
            minHeap.push({count, num});

            // 如果堆大小超过 k，弹出频率最小的
            if (minHeap.size() > k) {
                minHeap.pop();
            }
        }

        // 4. 取出堆中元素
        vector<int> result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top().second);
            minHeap.pop();
        }

        return result;
    }
};

```
295数据流的中位数
```cpp
class MedianFinder {
private:
    priority_queue<int> maxHeap; // 大根堆：存左半部分（存储较小一半的数，堆顶 = 左半部分最大值）
    priority_queue<int, vector<int>, greater<int>> minHeap; // 小根堆：存右半部分（存储较大一半的数，堆顶 = 右半部分最小值）

public:
    MedianFinder() {
        // 构造函数不需要做特殊操作
    }
    
    void addNum(int num) {
        // 1. 先插入大根堆
        maxHeap.push(num);

        // 2. 保证大根堆的最大值 ≤ 小根堆的最小值
        minHeap.push(maxHeap.top());
        maxHeap.pop();

        // 3. 保证大小堆平衡（大根堆数量 >= 小根堆数量）
        if (maxHeap.size() < minHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        // 1. 奇数个元素 → 大根堆多一个 → 中位数 = maxHeap.top()
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.top();
        } else {
            // 2. 偶数个元素 → 平均值
            return (maxHeap.top() + minHeap.top()) / 2.0;
        }
    }
};

```