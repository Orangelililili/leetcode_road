https://leetcode.cn/problems/two-sum/description/

//使用数组和set来做哈希法的局限。
//数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
//set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，
//因为要返回x 和 y的下标。所以set 也不能用。
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        //map目的用来存放我们访问过的元素，因为遍历数组的时候，
        //需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）
        //那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。
        unordered_map <int,int> map;//不需要有序，所以用unordered_map
        //遍历nums，每查找一个数，找map里面是否有和它对应的可以组成target的值
        for(int i=0;i<nums.size();i++){
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto ptr=map.find(target-nums[i]);
            if(ptr!=map.end()){
                return {ptr->second, i};//其中 ptr->second 是找到的值
            }//就是返回两个下标
            
            //没有就将访问过的元素和下标存到map里面
            map.insert(pair<int,int>(nums[i], i));
        }
        return {};
    }
};