# 回溯理论基础

## 1. 回溯算法的基本概念

**回溯算法（Backtracking）**是一种通过探索所有可能的候选解来找出所有解的算法。当探索到某一步时，如果发现这个选择不能得到有效解，就回退一步，尝试其他选择。

### 1.1 基本术语

- **路径（Path）**：已经做出的选择，即当前搜索路径
- **选择列表（Choices）**：当前可以做的选择
- **结束条件（Termination）**：到达决策树底层，无法再做选择的条件
- **回溯（Backtrack）**：撤销当前选择，返回上一层继续搜索
- **剪枝（Pruning）**：提前终止不可能产生有效解的搜索路径

### 1.2 回溯算法的特点

- **递归实现**：回溯算法通常用递归实现
- **穷举搜索**：尝试所有可能的路径
- **状态恢复**：每次回溯都要恢复状态
- **剪枝优化**：通过条件判断减少不必要的搜索

**示例**：
```
回溯算法的搜索过程可以看作是一棵决策树：

        开始
       /  |  \
      选择1 选择2 选择3
     /  |  \
   选择1 选择2 选择3
   
当某个路径不满足条件时，回溯到上一层，尝试其他选择。
```

### 1.3 回溯算法的本质

**回溯算法的本质是暴力搜索的优化**：
- 通过递归实现深度优先搜索
- 在搜索过程中进行剪枝，减少无效搜索
- 通过回溯恢复状态，避免重复计算

**核心思想**：
- **for循环横向遍历**：处理本层的所有选择
- **递归纵向遍历**：深入下一层继续搜索
- **回溯不断调整结果集**：撤销选择，尝试其他路径

## 2. 回溯三部曲

回溯算法的实现遵循**回溯三部曲**：

### 2.1 第一步：确定递归函数参数和返回值

**参数**：
- 通常需要传入：原始数据、当前搜索位置、路径、结果集等
- 根据具体问题调整参数

**返回值**：
- 通常是`void`，通过全局变量或引用传递结果

**示例**：
```cpp
void backtracking(vector<int>& nums, int startIndex, vector<int>& path, vector<vector<int>>& result) {
    // 回溯逻辑
}
```

### 2.2 第二步：确定终止条件

**终止条件**：
- 当满足题目要求时，将当前路径加入结果集
- 当无法继续搜索时，直接返回

**常见终止条件**：
- 路径长度达到要求
- 路径和达到目标值
- 搜索位置到达末尾
- 满足特定条件

**示例**：
```cpp
if (path.size() == k) {
    result.push_back(path);
    return;
}
```

### 2.3 第三步：确定单层搜索逻辑

**单层搜索逻辑**：
1. **for循环**：遍历本层的所有选择
2. **处理节点**：将当前选择加入路径
3. **递归**：进入下一层搜索
4. **回溯**：撤销当前选择，恢复状态

**模板代码**：
```cpp
for (int i = startIndex; i < nums.size(); i++) {
    // 处理节点
    path.push_back(nums[i]);
    
    // 递归
    backtracking(nums, i + 1, path, result);
    
    // 回溯，撤销处理结果
    path.pop_back();
}
```

## 3. 回溯算法核心模板

### 3.1 通用回溯模板

**核心模板**：
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**完整示例**：
```cpp
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path;           // 存放每一个结果
    
    void backtracking(int n, int k, int startIndex) {
        // 终止条件
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        
        // 单层搜索逻辑
        for (int i = startIndex; i <= n; i++) {
            path.push_back(i);              // 处理节点
            backtracking(n, k, i + 1);      // 递归
            path.pop_back();                 // 回溯，撤销操作
        }
    }
    
public:
    vector<vector<int>> combine(int n, int k) {
        result.clear();
        path.clear();
        backtracking(n, k, 1);
        return result;
    }
};
```

### 3.2 回溯算法的树形结构理解

**理解回溯的关键**：
- **for循环横向遍历**：处理本层的所有选择
- **递归纵向遍历**：深入下一层继续搜索
- **回溯不断调整结果集**：撤销选择，尝试其他路径

**示例树形结构**（组合问题，n=4, k=2）：
```
                    []
         /          |          \
        [1]         [2]         [3]
      /   \        /   \         |
   [1,2] [1,3]  [2,3] [2,4]   [3,4]
    /       \      |      |
[1,2,3] [1,2,4] [2,3,4] [2,4,?]
```

## 4. 组合问题模板

### 4.1 基础组合问题

**适用场景**：从n个数中选择k个数的所有组合

**核心思路**：
- 使用`startIndex`控制搜索起始位置，避免重复
- 路径长度达到k时，加入结果集

**模板代码**：
```cpp
// LeetCode 77. 组合
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        
        for (int i = startIndex; i <= n; i++) {
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> combine(int n, int k) {
        result.clear();
        path.clear();
        backtracking(n, k, 1);
        return result;
    }
};
```

**关键点**：
- `startIndex`：控制搜索起始位置，避免重复
- 剪枝优化：`i <= n - (k - path.size()) + 1`

### 4.2 组合总和（可重复使用元素）

**适用场景**：从数组中选择元素，使其和等于目标值，元素可以重复使用

**核心思路**：
- 递归时传入`i`而不是`i+1`，允许重复使用当前元素
- 及时剪枝：当和超过目标值时直接返回

**模板代码**：
```cpp
// LeetCode 39. 组合总和
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backTracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return; // 及时剪枝
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }
        
        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backTracking(candidates, target, sum, i); // 不用i+1了，表示可以重复读取当前的数
            sum -= candidates[i];
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backTracking(candidates, target, 0, 0);
        return result;
    }
};
```

**关键点**：
- 递归传入`i`：允许重复使用当前元素
- 及时剪枝：`sum > target`时直接返回

### 4.3 组合总和II（有重复元素，不可重复使用）

**适用场景**：从有重复元素的数组中选择元素，使其和等于目标值，每个元素只能使用一次

**核心思路**：
- 先排序，便于去重
- 使用`i > startIndex && candidates[i] == candidates[i-1]`去重
- 递归传入`i+1`，不允许重复使用

**模板代码**：
```cpp
// LeetCode 40. 组合总和II
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backTracking(vector<int>& candidates, int target, int startIndex, int sum) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        
        for (int i = startIndex; i < candidates.size(); i++) {
            // 跳过重复元素
            if (i > startIndex && candidates[i] == candidates[i - 1]) continue;
            
            sum += candidates[i];
            path.push_back(candidates[i]);
            backTracking(candidates, target, i + 1, sum);
            sum -= candidates[i];
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // 排序，便于去重
        backTracking(candidates, target, 0, 0);
        return result;
    }
};
```

**关键点**：
- 排序：`sort(candidates.begin(), candidates.end())`
- 去重：`i > startIndex && candidates[i] == candidates[i-1]`
- 递归传入`i+1`：不允许重复使用

### 4.4 组合总和III

**适用场景**：从1-9中选择k个数，使其和等于n

**核心思路**：
- 在基础组合问题基础上，增加和的条件判断
- 剪枝：当和超过目标值时直接返回

**模板代码**：
```cpp
// LeetCode 216. 组合总和III
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        if (sum > targetSum) { // 剪枝操作
            return;
        }
        if (path.size() == k) {
            if (sum == targetSum) result.push_back(path);
            return;
        }
        
        for (int i = startIndex; i <= 9; i++) {
            sum += i;
            path.push_back(i);
            backtracking(targetSum, k, sum, i + 1);
            sum -= i;
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear();
        path.clear();
        backtracking(n, k, 0, 1);
        return result;
    }
};
```

**关键点**：
- 双重条件：路径长度达到k且和等于目标值
- 剪枝：`sum > targetSum`时直接返回

## 5. 分割问题模板

### 5.1 分割回文串

**适用场景**：将字符串分割成所有可能的回文子串

**核心思路**：
- 使用`startIndex`表示分割起始位置
- 判断子串是否为回文，如果是则继续分割

**模板代码**：
```cpp
// LeetCode 131. 分割回文串
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path;
    
    void backTracking(string s, int startIndex) {
        if (startIndex == s.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = startIndex; i < s.size(); i++) {
            // 检查s[startIndex...i]是否是回文
            if (isPalindrome(s, startIndex, i)) {
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
                backTracking(s, i + 1);
                path.pop_back();
            }
        }
    }
    
    bool isPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start] != s[end]) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
    
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backTracking(s, 0);
        return result;
    }
};
```

**关键点**：
- 判断回文：双指针判断子串是否为回文
- 分割位置：`startIndex`到`i`的子串

### 5.2 复原IP地址

**适用场景**：将字符串复原成有效的IP地址

**核心思路**：
- 使用点号数量控制分割次数（3个点号）
- 判断每段是否合法（0-255，不能以0开头）

**模板代码**：
```cpp
// LeetCode 93. 复原IP地址
class Solution {
private:
    vector<string> result;
    
    void backTracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) {
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        
        for (int i = startIndex; i < s.size() - 1; i++) {
            if (isValid(s, startIndex, i)) {
                s.insert(s.begin() + i + 1, '.');
                pointNum++;
                backTracking(s, i + 2, pointNum);
                pointNum--;
                s.erase(s.begin() + i + 1);
            } else {
                break; // 不合法，直接结束本层循环
            }
        }
    }
    
    bool isValid(const string& s, int start, int end) {
        if (start > end) return false;
        if (s[start] == '0' && start != end) return false; // 0开头的数字不合法
        
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') return false;
            num = num * 10 + (s[i] - '0');
            if (num > 255) return false;
        }
        return true;
    }
    
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        backTracking(s, 0, 0);
        return result;
    }
};
```

**关键点**：
- 点号数量：使用`pointNum`控制分割次数
- 合法性判断：0-255，不能以0开头（除非是单独的0）
- 剪枝：不合法时直接`break`

## 6. 子集问题模板

### 6.1 子集（无重复元素）

**适用场景**：找出数组的所有子集

**核心思路**：
- 每个节点都是结果，需要在递归开始就收集
- 不需要终止条件，或者终止条件在for循环中

**模板代码**：
```cpp
// LeetCode 78. 子集
class Solution {
private:
    vector<int> path;
    vector<vector<int>> result;
    
    void backTracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size()) {
            return;
        }
        
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        result.clear();
        backTracking(nums, 0);
        return result;
    }
};
```

**关键点**：
- 每个节点都是结果：在递归开始就`result.push_back(path)`
- 不需要特殊终止条件：for循环自然终止

### 6.2 子集II（有重复元素）

**适用场景**：找出有重复元素数组的所有子集（去重）

**核心思路**：
- 先排序，便于去重
- 使用`i > startIndex && nums[i] == nums[i-1]`去重

**模板代码**：
```cpp
// LeetCode 90. 子集II
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        
        for (int i = startIndex; i < nums.size(); i++) {
            // 跳过重复元素
            if (i > startIndex && nums[i] == nums[i - 1]) continue;
            
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序，便于去重
        backtracking(nums, 0);
        return result;
    }
};
```

**关键点**：
- 排序：`sort(nums.begin(), nums.end())`
- 去重：`i > startIndex && nums[i] == nums[i-1]`

### 6.3 递增子序列

**适用场景**：找出数组的所有递增子序列（去重）

**核心思路**：
- 不能排序（要保持原数组顺序）
- 使用`used`数组或`unordered_set`去重
- 确保递增：当前元素必须大于等于路径最后一个元素

**模板代码**：
```cpp
// LeetCode 491. 递增子序列
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        
        int used[201] = {0}; // 使用数组去重，+100处理负数
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back())
                || used[nums[i] + 100] == 1) {
                continue;
            }
            used[nums[i] + 100] = 1; // 记录这个元素在本层用过了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

**关键点**：
- 不能排序：保持原数组顺序
- 使用数组去重：`used[nums[i] + 100]`（+100处理负数）
- 递增判断：`nums[i] >= path.back()`

## 7. 排列问题模板

### 7.1 全排列（无重复元素）

**适用场景**：找出数组的所有排列

**核心思路**：
- 使用`used`数组标记已使用的元素
- 每次从0开始遍历，跳过已使用的元素

**模板代码**：
```cpp
// LeetCode 46. 全排列
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == true) continue; // path里已经收录的元素，直接跳过
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    
    vector<int> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

**关键点**：
- 使用`used`数组：标记已使用的元素
- 从0开始遍历：排列问题需要从头开始
- 跳过已使用：`if (used[i] == true) continue`

### 7.2 全排列II（有重复元素）

**适用场景**：找出有重复元素数组的所有排列（去重）

**核心思路**：
- 先排序，便于去重
- 使用`used`数组标记已使用的元素
- 去重：`i > 0 && nums[i] == nums[i-1] && used[i-1] == false`

**模板代码（排序去重）**：
```cpp
// LeetCode 47. 全排列II（方法1：排序去重）
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            // 去重：同一层不能使用相同元素
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
    
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序，便于去重
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

**模板代码（set去重）**：
```cpp
// LeetCode 47. 全排列II（方法2：set去重）
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    
    void backtracking(vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        unordered_set<int> uset; // 控制某一节点下的同一层元素不能重复
        for (int i = 0; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            if (used[i] == false) {
                uset.insert(nums[i]); // 记录元素
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
    
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end());
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

**关键点**：
- 排序：`sort(nums.begin(), nums.end())`
- 去重条件：`i > 0 && nums[i] == nums[i-1] && used[i-1] == false`
- 或使用`unordered_set`：控制同一层元素不重复

## 8. 其他回溯问题模板

### 8.1 电话号码的字母组合

**适用场景**：根据电话号码数字，返回所有可能的字母组合

**核心思路**：
- 建立数字到字母的映射
- 每个数字对应多个字母，需要遍历所有可能

**模板代码**：
```cpp
// LeetCode 17. 电话号码的字母组合
class Solution {
private:
    const string letterMap[10] = {
        "",      // 0
        "",      // 1
        "abc",   // 2
        "def",   // 3
        "ghi",   // 4
        "jkl",   // 5
        "mno",   // 6
        "pqrs",  // 7
        "tuv",   // 8
        "wxyz",  // 9
    };
    vector<string> result;
    string s;
    
    void backTracking(const string& digits, int startIndex) {
        if (startIndex == digits.size()) {
            result.push_back(s);
            return;
        }
        
        int digit = digits[startIndex] - '0';
        string letters = letterMap[digit];
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);
            backTracking(digits, startIndex + 1);
            s.pop_back();
        }
    }
    
public:
    vector<string> letterCombinations(string digits) {
        result.clear();
        s.clear();
        if (digits.size() == 0) {
            return result;
        }
        backTracking(digits, 0);
        return result;
    }
};
```

**关键点**：
- 建立映射：数字到字母的映射表
- 遍历所有可能：每个数字对应的所有字母

### 8.2 重新安排行程

**适用场景**：根据机票信息，重新安排行程（欧拉路径问题）

**核心思路**：
- 使用`unordered_map<string, map<string, int>>`存储航班信息
- 使用回溯找到一条完整路径

**模板代码**：
```cpp
// LeetCode 332. 重新安排行程
class Solution {
private:
    unordered_map<string, map<string, int>> targets;
    
    bool backtracking(int ticketNum, vector<string>& result) {
        if (result.size() == ticketNum + 1) {
            return true;
        }
        
        for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
            if (target.second > 0) {
                result.push_back(target.first);
                target.second--;
                if (backtracking(ticketNum, result)) {
                    return true;
                }
                result.pop_back();
                target.second++;
            }
        }
        return false;
    }
    
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++;
        }
        vector<string> result;
        result.push_back("JFK");
        backtracking(tickets.size(), result);
        return result;
    }
};
```

**关键点**：
- 使用map存储：`unordered_map<string, map<string, int>>`
- 记录航班次数：使用次数控制是否可用
- 找到一条路径即返回：`if (backtracking(...)) return true`

## 9. 去重技巧总结

### 9.1 排序去重

**适用场景**：数组可以排序的情况

**方法**：
1. 先对数组排序：`sort(nums.begin(), nums.end())`
2. 在for循环中去重：`if (i > startIndex && nums[i] == nums[i-1]) continue`

**示例**：
```cpp
// 组合总和II、子集II、全排列II
sort(candidates.begin(), candidates.end());
for (int i = startIndex; i < candidates.size(); i++) {
    if (i > startIndex && candidates[i] == candidates[i - 1]) continue;
    // ...
}
```

**关键点**：
- `i > startIndex`：确保是同一层的重复，不是同一路径的重复
- 组合/子集问题：`i > startIndex`
- 排列问题：`i > 0 && used[i-1] == false`

### 9.2 Set去重

**适用场景**：数组不能排序或需要更灵活的去重

**方法**：
1. 在for循环中使用`unordered_set`记录本层已使用的元素
2. 每次循环检查是否已使用

**示例**：
```cpp
// 递增子序列、全排列II
unordered_set<int> uset;
for (int i = startIndex; i < nums.size(); i++) {
    if (uset.find(nums[i]) != uset.end()) continue;
    uset.insert(nums[i]);
    // ...
}
```

**关键点**：
- 控制同一层元素不重复
- 不需要排序，适用于不能排序的情况

### 9.3 数组去重

**适用场景**：元素范围较小，可以用数组索引

**方法**：
1. 使用数组记录本层已使用的元素
2. 适用于元素范围在合理范围内的情况

**示例**：
```cpp
// 递增子序列
int used[201] = {0};
for (int i = startIndex; i < nums.size(); i++) {
    if (used[nums[i] + 100] == 1) continue; // +100处理负数
    used[nums[i] + 100] = 1;
    // ...
}
```

**关键点**：
- 需要知道元素范围
- 可能需要偏移处理负数

## 10. 剪枝优化技巧

### 10.1 组合问题剪枝

**剪枝条件**：
- 剩余元素不足：`i <= n - (k - path.size()) + 1`

**示例**：
```cpp
// 组合问题剪枝
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
    // ...
}
```

### 10.2 组合总和剪枝

**剪枝条件**：
- 和超过目标值：`if (sum > target) return;`

**示例**：
```cpp
// 组合总和剪枝
void backTracking(...) {
    if (sum > target) {
        return; // 及时剪枝
    }
    // ...
}
```

### 10.3 其他剪枝

**常见剪枝条件**：
- 不满足条件时直接`break`或`continue`
- 提前终止不可能产生有效解的路径

**示例**：
```cpp
// 复原IP地址剪枝
for (int i = startIndex; i < s.size() - 1; i++) {
    if (isValid(s, startIndex, i)) {
        // ...
    } else {
        break; // 不合法，直接结束本层循环
    }
}
```

## 11. 回溯算法的时间复杂度

### 11.1 时间复杂度分析

| 问题类型 | 时间复杂度 | 说明 |
|:--------:|:---------:|:----:|
| **组合问题** | O(C(n,k)) | 从n个元素中选择k个的组合数 |
| **排列问题** | O(n!) | n个元素的全排列 |
| **子集问题** | O(2^n) | n个元素的所有子集 |
| **分割问题** | O(2^n) | 最坏情况下需要尝试所有分割方式 |
| **一般回溯** | O(分支数^深度) | 取决于问题的分支数和深度 |

**注意**：
- 实际时间复杂度可能因为剪枝而大大降低
- 空间复杂度主要是递归栈的深度，通常为O(深度)

### 11.2 空间复杂度分析

| 操作 | 空间复杂度 | 说明 |
|:----:|:---------:|:----:|
| **递归栈** | O(深度) | 递归调用的栈空间 |
| **路径存储** | O(深度) | path数组的空间 |
| **结果存储** | O(结果数量) | result数组的空间 |
| **辅助数组** | O(n) | used数组等辅助空间 |

## 12. 何时使用回溯算法

### 12.1 使用场景

1. **组合问题**
   - 从n个元素中选择k个的所有组合
   - 组合总和、组合总和II等

2. **排列问题**
   - 找出数组的所有排列
   - 全排列、全排列II等

3. **子集问题**
   - 找出数组的所有子集
   - 子集、子集II等

4. **分割问题**
   - 将字符串或数组分割成满足条件的子集
   - 分割回文串、复原IP地址等

5. **搜索问题**
   - 在约束条件下搜索所有可能的解
   - N皇后、数独等

### 12.2 判断标准

**当遇到以下情况时，考虑使用回溯算法**：
- 需要找出所有可能的解（而不是最优解）
- 问题可以转化为树形结构
- 需要尝试所有可能的路径
- 可以通过剪枝优化搜索空间

**示例**：
```cpp
// 问题：找出所有从1到n中选择k个数的组合

// 回溯解法：尝试所有可能的组合
void backtracking(int n, int k, int startIndex) {
    if (path.size() == k) {
        result.push_back(path);
        return;
    }
    for (int i = startIndex; i <= n; i++) {
        path.push_back(i);
        backtracking(n, k, i + 1);
        path.pop_back();
    }
}
```

## 13. 回溯算法的优缺点

### 13.1 优点

- **思路清晰**：回溯三部曲，逻辑清晰
- **适用面广**：可以解决很多搜索问题
- **易于理解**：递归实现，符合人类思维
- **可以剪枝**：通过条件判断减少搜索空间

### 13.2 缺点

- **时间复杂度高**：最坏情况下需要遍历所有可能
- **空间复杂度**：递归栈可能很深
- **可能超时**：对于大规模问题，需要优化剪枝

## 14. 常见题型总结

### 14.1 组合类

1. **基础组合**
   - 77.组合：从n个数中选择k个数的所有组合

2. **组合总和**
   - 39.组合总和：可重复使用元素
   - 40.组合总和II：有重复元素，不可重复使用
   - 216.组合总和III：从1-9中选择k个数

### 14.2 分割类

1. **字符串分割**
   - 131.分割回文串：将字符串分割成所有可能的回文子串
   - 93.复原IP地址：将字符串复原成有效的IP地址

### 14.3 子集类

1. **基础子集**
   - 78.子集：找出数组的所有子集
   - 90.子集II：有重复元素的子集（去重）

2. **特殊子集**
   - 491.递增子序列：找出所有递增子序列

### 14.4 排列类

1. **基础排列**
   - 46.全排列：找出数组的所有排列
   - 47.全排列II：有重复元素的排列（去重）

### 14.5 其他类

1. **字符串回溯**
   - 17.电话号码的字母组合：根据电话号码数字返回所有可能的字母组合

2. **图论回溯**
   - 332.重新安排行程：欧拉路径问题

## 15. 总结

回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。

**核心要点**：
1. **回溯三部曲**：确定递归函数参数和返回值、确定终止条件、确定单层搜索逻辑
2. **核心模板**：for循环横向遍历，递归纵向遍历，回溯不断调整结果集
3. **去重技巧**：排序去重、set去重、数组去重
4. **剪枝优化**：通过条件判断减少不必要的搜索
5. **时间复杂度**：通常是指数级，但可以通过剪枝优化

**使用建议**：
- 理解回溯三部曲，掌握核心模板
- 根据问题类型选择合适的去重方法
- 注意剪枝优化，减少搜索空间
- 理解组合、排列、子集问题的区别
- 注意去重条件：同一层去重 vs 同一路径去重

**常见题型总结**：
- **组合类**：基础组合、组合总和系列
- **分割类**：分割回文串、复原IP地址
- **子集类**：子集、子集II、递增子序列
- **排列类**：全排列、全排列II
- **其他类**：电话号码的字母组合、重新安排行程

