https://leetcode.cn/problems/balanced-binary-tree/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
//二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

 //平衡二叉树（Balanced Binary Tree）是指一种特殊的二叉树，
 //在这种树中，任何一个节点的左右子树的高度差的绝对值不超过一个特定的值（通常是1）。
 //平衡二叉树的主要目的是确保二叉树的高度尽可能低，从而保持较高的查询效率。

 //因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）
 //所以平衡二叉树要用后序遍历
class Solution {
public:
//返回以该节点为根节点的二叉树深度，是平衡二叉树返回0，不是返回-1
    int getHight(TreeNode* node){
        if(node==nullptr) return 0;

        int leftTree=getHight(node->left);//左
        if(leftTree==-1) return-1;
        int rightTree=getHight(node->right);//右
        if(rightTree==-1) return-1;
        //// 以当前节点为根节点的树的最大高度
        return abs(leftTree-rightTree)>1? -1:1+max(leftTree,rightTree);
    }
    bool isBalanced(TreeNode* root) {
        //递归
        //1.明确递归参数和返回值
        //2.明确终止条件
        //3.明确的单层递归逻辑
        return getHight(root)==-1? false:true;
    }
};