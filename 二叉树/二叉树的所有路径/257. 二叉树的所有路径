https://leetcode.cn/problems/binary-tree-paths/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //回溯（Backtracking）是一种算法设计技术，通常用于寻找问题的所有解或最优解，尤其是那些具有多个解的组合优化问题。
 //回溯的基本思路是从一个初始状态出发，尝试所有可能的选择，在过程中通过逐步推进来构建解。
 //当发现当前选择不再有可能得到有效解时，就回退到上一步，并尝试其他的选择。
 //这种方法能够避免重复计算和不必要的计算，适用于解决一些决策树或约束满足问题（比如数独、八皇后问题）
class Solution {
private:
    void traversal(TreeNode* cur,vector<int>& path,vector<string>& result){
        //存放每一条路径的path，还有放最终结果的result

        path.push_back(cur->val);//中

        if(cur->left==nullptr&&cur->right==nullptr){
            //找到叶子节点（没有再往下的子节点）
            //然后回溯
            string spath;
            for(int i=0;i<path.size()-1;i++){
                //找到一个路径，转换成string;
                spath+=to_string(path[i]);//将数值类型（如整数、浮点数等）转换为字符串。
                //这个函数可以将各种基本数据类型（如 int、float、double 等）转换为 std::string 类型
                spath+="->";
            }
            //再加上最后一个元素
            spath+=to_string(path[path.size()-1]);
            //加入结果集
            result.push_back(spath);
            return;
        }

        //左
        if(cur->left){
            traversal(cur->left,path,result);//递归
            path.pop_back();//回溯
            //递归和回溯要一一对应
        }
        //右
        if(cur->right){
            traversal(cur->right,path,result);
            path.pop_back();
        }
    }
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        //要前序遍历，这样可以从根节点向子节点扩展
        //要先判断是否为空，不为空就进入递归
        //但是回溯之前要把加入path中节点删除
        //递归和回溯是一一对应的
        vector<string>result;
        vector<int>path;
        if(root==nullptr) return result;
        traversal(root,path,result);
        return result;
    }
};

//迭代
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt;// 保存树的遍历节点
        stack<string> pathSt;   // 保存遍历路径的节点
        vector<string> result;  // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点 中
            string path = pathSt.top();pathSt.pop();    // 取出该节点对应的路径
            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点
                result.push_back(path);
            }
            if (node->right) { // 右
                treeSt.push(node->right);
                pathSt.push(path + "->" + to_string(node->right->val));
            }
            if (node->left) { // 左
                treeSt.push(node->left);
                pathSt.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};